# oop

## 第一章、基本介绍

### 1.1 C语言优缺点

优点：

- Efficient programs（程序高效）
- Direct access to machine, suitable for OS and ES（操作底层）
- Flexible（灵活）

缺点：

- Insufficient type checking（类型检查不够）
- Poor support for programming-in-the-large（难以支持大程序）
- Procedure-oriented programming（面向过程）

### 1.2 C++进步

- Data abstraction
- Access control
- Initialization & cleanup
- References
- Function overloading
- Streams for I/O
- Name control
- Operator overloading
- More safe and powerful memory management
- Templates
- Exception handling

### 1.3 字符串

- 字符串是个类（加`#include<string>`）
- `find`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    //主要字符串是从0开始计数的
    cout<<"ab在str中的位置:"<<str.find("ab")<<endl;
    //返回第一次出现ab的位置,没有则返回一串乱码
    cout<<"ab在str[2]到str[n-1]中的位置:"<<str.find("ab",2)<<endl;
    //返回第一次从str[2]开始出现ab的位置,没有则返回一串乱码
    cout<<"ab在str[0]到str[2]中的位置:"<<str.rfind("ab",2)<<endl;
    //返回ab在str[0]到str[2]中的位置,没有则返回一串乱码
    return 0;
}
```

- `substr`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"返回str[3]及其以后的子串:"<<str.substr(3)<<endl;
    //若小于限制长度则报错
    cout<<"从ste[2]开始由四个字符组成的子串:"<<str.substr(2,4)<<endl;
    //若小于限制长度则报错
    return 0;
}
```

- `replace`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string line = "this@ is@ a test string!";
    line = line.replace(line.find("@"), 1, ""); //从第一个@位置替换第一个@为空
    cout<<line<<endl;
    return 0;
}
```

- `insert`函数

```c++
#include <string>
#include <iostream>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"从2号位置插入字符串jkl并形成新的字符串返回:"<<str.insert(2, "jkl")<<endl;
    return 0;
}
```

- `append`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"在字符串str后面添加字符串ABC:"<<str.append("ABC")<<endl;
    return 0;
}
```

- `swap`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str1,str2;
    cin>>str1>>str2;
    cout<<"str1:"<<str1<<endl;
    cout<<"str2:"<<str2<<endl;
    swap(str1, str2);
    cout<<"str1:"<<str1<<endl;
    cout<<"str2:"<<str2<<endl;
}
```

### 1.4 动态内存分配

- 为什么需要动态内存分配？

  存在程序的内存需求只能在**运行时确定**的情况

- 特点：

  1. C++中通过new关键字进行动态内存申请
  2. C++中的动态内存分配是**基于类型**进行的
  3. delete关键字用于内存释放

- new关键字与malloc函数的区别

| new关键字是C++的一部分              | malloc是由C库提供的函数        |
| :---------------------------------- | :----------------------------- |
| new以具体类型为单位进行内存分配     | malloc以字节为单位进行内存分配 |
| new在申请单个类型变量时可进行初始化 | malloc不具备内存初始化的特性   |

例子见https://blog.csdn.net/qq_40416052/article/details/82493916

- Tips：

  Don't use delete to free memory that new **didn't allocate**.

  Don't use delete to free the **same** block of memory twice in succession.

  Use delete [] if new [] was used to allocate an array.

  Use delete (no brackets) if new was used to allocate a single entity.

  It's **safe** to apply delete to the null pointer (nothing happens).

- **`delete`** 运算符的结果类型为 **`void`**，因此它不返回值

- 使用 **`delete`** 释放 C++ 类对象的内存时，将在释放该对象的内存之前调用该对象的析构函数（如果该对象具有析构函数）。

- 如果 **`delete`** 运算符的操作数是可修改的左值，则在删除该对象后未定义其值

- 对于不是类类型（[class](https://learn.microsoft.com/zh-cn/cpp/cpp/class-cpp?view=msvc-170)、[struct](https://learn.microsoft.com/zh-cn/cpp/cpp/struct-cpp?view=msvc-170) 或 [union](https://learn.microsoft.com/zh-cn/cpp/cpp/unions?view=msvc-170)）的对象，将调用**全局 delete** 运算符。 对于类类型的对象，如果 delete 表达式以一元范围解析运算符 (`::`) 开始，则会在全局范围中解析解除分配函数的名称。 否则，delete 运算符将在释放内存之前为对象调用析构函数（如果指针不为 null）。 可为每个类定义 delete 运算符；如果给定类不存在这种定义，则会调用全局 delete 运算符。 如果删除表达式用于释放其静态对象具有虚拟析构函数的类对象，则将通过对象的动态类型的虚拟析构函数解析释放函数。



## 第二章、Class

### 2.1 引用

- Reference is a new way to manipulate objects in C++：引用引入了对象的一个**同义词**。定义引用的表示方法与定义指针相似，只是用&代替了*。引用（reference）是c++对c语言的**重要扩充**。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：**类型 &引用变量名 = 已定义过的变量名**。

- 引用的特点：
  1. 一个变量可取**多个**别名。
  2. 引用必须**初始化**。
  3. 引用只能在初始化的时候引用一次 ，**不能更改**为转而引用其他变量。

- Tips：

  1. &在这里不是求地址运算，而是起**标识**作用

  2. 对引用求地址，就是对目标变量求地址。即引用名是目标变量名的一个别名。引用在**定义上**是说引用**不占据任何内存空间**，但是编译器在一般将其实现为**const指针**，即指向位置不可变的指针，所以引用实际上与一般指针同样占用内存

  3. **不能建立引用的数组**。因为数组是一个由若干个元素所组成的集合，所以无法建立一个由引用组成的集合，但是可以建立**数组的引用**
  4. 引用常见的使用用途：作为函数的参数、函数的返回值
  5. Bindings donʼt change at run time（运行时不变）, unlike pointers；Assignment changes the object referred-to

- Pointers vs. References

  References：can't be null（非空）

​                              are dependent on an existing variable, they are an alias for an variable（依赖）

​                              can't change to a new "address" location（不能改）

​        Pointers：can be set to null（可空）

​                         pointer is independent of existing objects（独立）

​                         can change to point to a different address（能改）

- 限制：没有引用的引用；没有指针的引用

```c++
int&* p; // illegal
void f(int*& p);//可以
```



### 2.2 类

#### 2.2.1 `::` resolver

<Class Name>::<function name>
::<function name>

#### 2.2.2 声明和定义

The class declaration, along with the prototype of the member functions should be put
into a **header file**（声明和函数原型放在头文件）
The definition of the member functions should be put into **another source file**（定义放在另一个文件）

#### 2.2.3 this指针

this 是 C++ 中的一个关键字，也是一个 **const 指针**，它指向**当前对象**，通过它可以访问当前对象的所有成员。

this 虽然用在类的内部，但是只有在对象被**创建以后**才会给 this 赋值，并且这个赋值的过程是编译器**自动完成**的，不需要用户干预，用户也**不能**显式地给 this 赋值（const指针）

this 实际上是成员函数的一个**形参**，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是**隐式**的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

this is a natural local variable of all structs member functions that you can not define,but can use it directly.（不能定义，但可以直接使用，自然局部变量）
Inside member functions, you can use this as the pointer to the variable that calls the function.（函数变量的指针）

#### 2.2.4 OOP 特性

1. Everything is an object.
2. A program is a bunch of objects telling each other what to do by sending messages.
3. Each object has its own memory made up of other objects.
4. Every object has a type.
5. All objects of a particular type can receive the same messages.

### 2.3 构造和析构

#### 2.3.1构造函数

- 构造函数是一种特殊的**成员函数**，不需要用户来调用，**定义**对象时被自动执行。
- 构造函数名字**与类名相同**，**无返回类型**。
- 如果我们没有定义构造函数，系统会为我们自动定义一个无参的默认构造函数的，它不对成员属性做任何操作，如果我们自己定义了构造函数，系统就不会为我们创建默认构造函数了。

```c++
struct Y {
float f;
int i;
Y(int a);
};
Y y1[] = { Y(1), Y(2), Y(3) }; // OK
Y y2[2] = { Y(1) }; Y y3[7]; // 错误
Y y4;//错误
```



#### 2.3.2 析构函数

- 析构函数执行对象的**清理**工作，当对象的生命周期结束的时候，会自动调用。析构函数的作用并不是删除对象，在对象撤销它所占用的内存之前，做一些清理的工作。清理之后，这部分内存就可以被系统回收再利用了。在设计这个类的时候，系统也会默认的提供一个析构函数。在对象的生命周期结束的时候，程序就会自动执行析构函数来完成这些工作。同构造函数，用户自己定义，系统自动调用。

```c++
class Y {
public:
~Y();
};
```

- 析构函数没有返回值，**没有参数**；
- 没有参数，所以**不能重载**，一个类仅有一个析构函数；
- 析构函数除了释放工作，还可以做一些用户希望它做的一些工作，比如输出一些信息
- 调用时间：当对象**超出作用域**时，编译器自动调用析构函数。例如：main函数里创建对象，在退出main函数之后，析构函数被调用。在main函数的外面创建的对象，这个对象的销毁是在我们退出程序之后。析构函数销毁对象的顺序与构建对象的顺序是**相反**的。因为对象的存储是在**栈**中的，栈的特性就是先进后出。

#### 2.3.4 存储分配

- The compiler allocates all the storage for a scope at the opening brace of that scope.（在作用域的开始大括号处为该作用域分配所有存储空间）
- The constructor call doesnʼt happen until the sequence point where the object is defined



## 第三章 类和对象

### 3.1类的定义

#### 3.1.1 编译单元

- The compiler sees only one .cpp file, and generates .obj file
- The linker links all .obj into one executable file
- To provide information about functions in other .cpp files, use .h

#### 3.1.2 头文件

- If a function is declared in a header file, you must include the header file **everywhere**

- If a class is declared in a header file, you must include the header file everywhere the class is used and where class member functions are defined
- Header = interface
  The header is a **contract** between you and the user of your code.
  The compiler enforces the contract by requiring you to declare all structures and functions before they are used.

- 内容：extern variables；function prototypes；class/struct declaration

- 形式：

  `#include`:include is to **insert** the included file into the .cpp file at where the #include

  statement is.

  `include "xx.h" `: search in the **current directory** firstly, then the directories declared somewhere（优先找当前文件夹）

  `include <xx.h>` : search in the **specified** directories

  `include <xx>` : same as include <xx.h>



## 第四章、容器

### 4.1 STL（标准模板库）

#### 4.1.1 优点

- Reduce development time.– Data-structures already written and debugged.
- Code readability（可读性）
- Fit more meaningful stuff on one page（紧凑）
- Robustness– STL data structures grow automatically.（自动增长）
- Portable code；Maintainable code（可移植，可维护）
- Easy

#### 4.1.2 模板库内容:

- A Pair class (pairs of anything, int/int, int/char, etc)
- Containers：Vector (expandable array)；Deque (expandable array, expands at both ends)；List (double-linked)；Sets and Maps
- Basic Algorithms (sort, search, etc)
- All identifiers in library are in std namespace: using namespace std;

#### 4.1.3 vector

- It is able to **increase its internal capacity** as required: as more items are added, it simply makes enough room for them.（自动增长的内存）
- It keeps its own private count of how many items it is currently storing.   Its size method returns the number of objects currently stored in it.（统计有多少项，`.size()`函数返回个数）
- It maintains the order of items you insert into it.   You can later retrieve them in the same order（顺序储存）

函数：

```c++
v.assign(2, 3);//将 2 个 3 赋值给 v
v.swap(v1);//交换两个容器的内容
v.push_back(4);//在末尾添加元素 4
v.pop_back();//删除最后一个元素
v.front();//返回第一元素
v.back();//返回最末元素
v.clear();//清空容器
v.empty();//容器为空返回true, 否则返回 false
```

初始化方式：

```c++
vector<int> v(100);//预先定义
v[80]=1; // okay
v[200]=1; // bad

vector<int> v2;//自动增长
int i;
while (cin >> i)
v.push_back(i);
```

#### 4.1.4 list

- 用法和vector等容器基本相同, 但是内部结构区别很大

函数：

```c++
l.push_front(3);//在头部插入元素 3
l.push_back(3);//在末端插入元素 3
l.pop_front();//删除第一元素
l.pop_back();//删除最末元素
l.front();//返回第一元素
l.back();//返回最末元素
l.clear();//清空容器
l.empty();//容器为空返回 true, 否则返回 false
```

#### 4.1.5 map

- Maps are collections that contain pairs of values.（一对值）
- Pairs consist of a key and a value.（键值与值的映射）
- Lookup works by supplying a key, and retrieving a value.

#### 4.1.6 stl的使用

- `vector<Student> v1;`：定义了一个存储 `Student` 类型对象的 vector 容器，对象直接保存在容器`vector<Student&> v2;`：定义了一个存储 `Student` 类型的引用的 vector 容器，但是由于引用类型不能被拷贝和赋值，所以这种写法不符合语法规范。

  `vector<Student*> v3;`：定义了一个存储指向 `Student` 类型对象的指针的 vector 容器，即对象的地址保存在容器中。

### 4.2 Iterators

- Declaring

  ```c++
  list<int>::iterator li;
  list<int> L;
  li = L.begin();//Front of container
  li = L.end();//Past the end
  ```

- 迭代器都可以进行`++`操作。反向迭代器和正向迭代器的区别在于：

  - 对正向迭代器进行`++`操作时，迭代器会指向容器中的后一个元素；
  - 而对反向迭代器进行`++`操作时，迭代器会指向容器中的前一个元素。

- 正向迭代器:假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以**互相赋值**，还可以用`==`和`!=`运算符进行**比较**。
- 双向迭代器:双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则`--p`和`p--`都是有定义的。`--p`使得 p 朝和`++p`相反的方向移动。

### 4.3 Algorithms

- Advantages of foreach loop:

  It eliminates the possibility of errors and makes the code more readable.(不会错)

  Easy to implement（可读性）

  Does not require pre-initialization of the iterator（不用初始化迭代器）

- Disadvantages of foreach loop:

  Cannot directly access the corresponding element indices（不能直接访问元素）

  Cannot traverse the elements in reverse order（无法逆序）

  It doesnʼt allow the user to skip any element as it traverses over each one of them（无法跳过）

### 4.4 Typdefs

- Annoying to type long names,like:

  ```c++
  typedef PB map<Name,list<PhoneNum> >;
  PB phonebook;
  PB::iterator finger;
  ```

  Easy to change implementation.

### 4.5 Pitfalls

- Accessing an invalid

  ```c++
  vector<int> v;
  v[100]=1; // 不一定能取到
  ```

  Solutions:

  - use push_back()
  - Preallocate with constructor.（预先分配空间）
  - Reallocate with reserve()（重新分配内存）
  - Check capacity()

- Use invalid iterator

```c++
list<int> L;

list<int>::iterator li;

li = L.begin();

L.erase(li);

++li; // WRONG

// Use return value of erase to advance

li = L.erase(li); // RIGHT
```



## 第五章、Functions

### 5.1 局部变量

Local variables are defined **inside a method**, have a scope limited to the method to which they belong.

- 如果一个局部变量和类的成员变量(字段)拥有相同的名字，这样会导致方法内部无法直接访问这个字段。这是因为，当编译器遇到这样的情况时，它会默认使用局部变量而不是类成员变量。这种现象被称为"名称遮掩（Name Hiding）"。

  例如，假设我们定义了一个名为 `Foo` 的类，并在其中声明了一个整型成员变量 `value`：

  ```c++
  class Foo {
  public:
    int value;   // 成员变量（字段）
    void bar() {
      int value = 42;   // 局部变量
      // ...
    }
  };
  ```

  在上面例子中，`bar()`函数内部定义了一个局部变量`value`来存放值为42的整数，此时如果需要在该函数中访问`value`成员变量，就会产生名称遮掩，即编译器会自动**取局部变量**而非class的成员`value`。

- Fields（成员变量）, parameters, local variables比较：

1. Fields：成员变量是定义在**类或结构体中**的变量，在**实例化**该类或结构体时会**被创建**。成员变量可以被整个类内的函数所使用，同时也可以被类的外部所访问，并且成员变量的值在整个**类的生存期**内都是存在的。
2. Parameters：函数参数是在调用函数时传递给该函数的一组值。它们只在函数内部起作用，并且在函数**执行完成后就被销毁**了。
3. Local Variables：局部变量是在函数内部定义的变量。与函数参数一样，它们也只在函数内部起作用，并且在函数结束时就会销毁。
4. Fields are defined outside constructors and methods
5. Formal parameters are defined in the header of a constructor or method.     They receive their values from outside, being initialized by the actual parameter values that form part of the constructor or method call（传参的时候由特定的构造函数初始化形参）

### 5.2 C++ access control

#### 5.2.1 访问形式

通过使用访问修饰符来限制类成员变量或函数的可见性。C++ 共有三种形式的访问控制：public、private 和 protected。

- Public：公共的成员变量和函数可以被类的任何地方的代码所访问，包括该**类的对象、子类、其他非子类**等。
- Private：私有的成员变量和函数只能由包含它们的**类本身所访问**，其他任何类型的对象都无法直接访问。继承自该类的子类及其他任何类都无法访问这些成员。
- Protected：受保护的成员变量和函数和私有成员一样，不能被类外部的代码直接访问，但是可以被继承自该类的**子类所访问**。而其他非子类的代码仍然不能访问。

- **默认情况**下，C++ 类定义的成员变量和成员函数的访问级别为 `private`

#### 5.2.2 Friends

可以通过友元函数或友元类(friends)来实现某些函数或类对于其他类的**私有/受保护成员的访问**。友元是一种特殊的访问修饰符，与`public`, `private`, 和 `protected`不同。

```c++
class MyClass {
 private:
  int myVar;
  // 友元类能够访问该类的私有成员
  friend class MyFriendClass;
     // 友元函数能够访问该类的私有成员
  friend void setMyVar(MyClass &obj, int val);
};
void setMyVar(MyClass &obj, int val) {
  obj.myVar = val;   // 在友元函数中设置私有成员变量的值
}
class MyFriendClass {
 public:
  void setMyVar(MyClass &obj, int val) {
    obj.myVar = val;   // 从友元类中设置私有成员变量的值
  }
};
int main() {
  MyClass obj;
  MyFriendClass frd;
  frd.setMyVar(obj, 42);   // 在main函数中使用friend类设定值
  return 0;
}
```

#### 5.2.3 class vs. struct

- class defaults to private

- struct defaults to public.

### 5.3 Initialization

#### 5.3.1 初始化列表

初始化列表是用于定义类构造函数时指定初始值的一种方式。初始化列表也可以用于结构体和联合体初始化

当对象创建时，成员变量的初始化被放在它们的申明中或者在构造函数内部。如果我们直接在构造函数中通过赋值语句来初始化成员变量，那么就会多出一个**额外的步骤**：首先调用默认构造函数来初始化这些成员变量，然后再用指定的表达式进行覆盖复制。

- pseudo-constructor calls for built-ins(用内置函数的伪构造函数调用)

- Order of initialization is order of declaration – Not the order in the list（类成员变量的初始化顺序始终按照它们在类中声明的顺序进行，而不是在构造函数初始化列表中指定的顺序）

- Destroyed in the reverse order.（销毁顺序**相反**）

- Initialization vs. assignment

  ```c++
  Student::Student(string s):name(s) {}//initialization
  ```

  before constructor

  ```c++
  Student::Student(string s) {name=s;}//assignment
  ```

  inside constructor

  string must have a default constructor

#### 5.3.2 Overloaded constructors

可以为一个类定义多个不同的构造函数，这些构造函数使用相同的名称但带有**不同的参数列表**。

- 可以为参数提供**默认值**。如果调用该函数时**省略**了默认参数，则将使用预定义的默认值来**自动初始化**参数。

  下面是默认参数规则的几个要点：

  1. **默认参数必须出现在函数声明中的非默认参数之后**，即所有有默认值的参数都在末尾，否则编译器会报错。
  2. 函数调用时，如果有缺省参数，那么可以不传递该参数，并按照函数原型中所列出的默认值赋值，例如：`myFunction();`
  3. 可以直接跳过某个有默认值的参数并在调用时给定其后面的参数，例如：`myFunction(42);`
  4. 在声明函数时，可以指定参数的默认值。示例代码如下：

  ```c++
  int myFunction(int x, int y=5, bool z=true) 
  int chico(int n, int m = 6, int j);//illeagle
  int result1 = myFunction(10);          //y被隐式设置为5， z被隐式设置为true
  int result2= myFunction(10,20,false); //y被设置为20，z被设置为false
  ```

#### 5.3.3 Pitfall of default arguments

- The default arguments are declared in its prototype, not defined in its function head：Can not put default arguments in definition（默认参数只需要在函数原型或者函数声明中提供，而**不需要**在函数定义中再次列出）

```c++
// 非法：定义中不应该有默认参数
void myFunction(int a=0, int b) { ... }
// 非法：同时出现了函数声明和定义中的默认参数
void myFunction(int a=0, int b=5) {
  ...
}
// 非法定义例子，超过了函数原型的作用域范围
void myFunction(int a, int b=5) { 
  // 函数原型/outside的默认b=5.
  ...
  void innerFunction(int x, int y=b); // error-不能使用外部函数的默认参数
  ...
}

```

### 5.4 inline function

内联（inline）函数是一些较小的函数，通常包含少量语句并不需要执行长时间运算。其实现过程是，编译器会将 "内联函数" 的代码**插入**到程序中的每个调用处，而**不是实际上去创建该函数**，并在程序执行时动态调用它，从而节省了函数调用本身所需的时间

- Repeat inline keyword at declaration and definition.

- An inline function definition may not generate any code in .obj file.

- So you can put inline functionsʼ bodies in **header file**. Then #include it where the function is needed.

  Never be afraid of multi-definition of inline functions, Definitions of inline functions are just **declarations.**

- The compiler does not have to honor your request to make a function inline. It might

  decide the function is too large or notice that it calls itself (recursion is not allowed or

  indeed possible for inline functions), or the feature might not be implemented for your

  particular compiler（编译器自己判断是否内联，递归或过大就不内联）

  

  Any function you define inside a class declaration is automatically an inline（类里定义的函数自动变成内联函数）

- You can put the definition of an inline member function out of the class braces.

  But the definition of the functions should be put before where they may be called.（编译器必须能够看到内联函数的函数体，否则就无法展开该函数的实现代码）

## 第六章、常量

### 6.1 const关键字

declares a variable to have a **constant** value

```c++
const int x = 123;
x = 27; // illegal!
x++; // illegal!
int y = x; // Ok, copy const to non-const
y = x; // Ok, same thing
const int z = y; // ok, const is safer
```

- Constants are variables，observe scoping rules（常量是一种变量，因此遵守作用域法则）
- the compiler tries to avoid creating storage for a const -- holds the value in its symbol table.（编译器不给常量空间，使用 `extern` 强制分配存储空间）
- 必须初始化，除非用`extern`

Compile time constants

```c++
const int bufsize = 1024;//value must be initialized
extern const int bufsize;
```

#### 6.1.1 Run-time constants

数组的长度必须是一个常量表达式(constant expression)，也就是说，在编译时可以确定的一个常量值。因此，在定义数组时，我们不能使用**运行时变量**来指定数组的长度。

```c++
const int class_size = 12;
int finalGrade[class_size]; // ok
int x;
cin >> x;
const int size = x;
double classAverage[size]; // error!
```

#### 6.1.2 聚合（Aggregates）

聚合（Aggregate）是指一些简单的数据类型的集合。聚合类型具有以下特性：

1. 是一个类或结构体；
2. 没有用户自定义的构造函数、析构函数和赋值运算符重载；
3. 所有成员都是 public 的；
4. 没有虚函数；

- Itʼs possible to use const for aggregates, but storage will be allocated. In these situations, const means a piece of storage that **cannot be changed.**

  However, the value cannot be used at compile time because the compiler is not required to know the contents of the storage at compile time（可以使用 `const` 关键字将聚合类型定义为常量，使其分配存储空间并不能够更改其值。但是在编译时，因为编译器无法知道其内容，所以不能将其用于数组大小或结构体成员的初始化参数等需要在编译时执行的地方。）

```c++
const int i[] = { 1, 2, 3, 4 };
float f[i[3]]; // Illegal
struct S { int i, j; };
const S s[] = { { 1, 2 }, { 3, 4 } };
double d[s[1].j]; // Illegal
```

### 6.2 Pointers and const

指针（Pointers）和 `const` 常量（Constants）可以结合使用，`const` 关键字可以应用于指针本身或指针所指向的对象。具体来说，如果是将 `const` 应用于**指针本身**，则表示该指针变量**本身不能被更改**；而如果是将 `const` 应用于指针所指向的**对象**，则表示该**对象不能被修改**。

```c++
char * const q = "abc"; // q is const
*q = 'c'; // OK
q++; // ERROR
const char *p = "ABCD"; // (*p) is a const char
*p = 'b'; // ERROR! (*p) is the const
```

|                | **int i;** | **const int ci = 3;** |
| -------------- | ---------- | --------------------- |
| int *ip;       | ip = &i;   | ip = &ci; // ERROR    |
| const int *cip | cip = &i;  | cip = &ci;            |

```c++
*ip = 54; // always legal since ip points to int
*cip = 54; // never legal since cip points to const int
```

#### 6.2.1 String Literals

```c++
char* s = "Hello, world!";
```

- This is actually a **const char *s** but compiler accepts it without the const
- If you want to change the string, put it in an **array**

#### 6.2.2 Conversions

- Can always treat a non-const value as const
-  cannot treat a constant object as non-constant without an explicit cast

```c++
void f(const int* x);
int a = 15;
f(&a); // ok
const int b = a;
f(&b); // ok
b = a + 1; // Error!
```

### 6.3 Passing and returning addresses

- Passing a whole object may cost you a lot. It is better to pass by a pointer. But itʼs possible for the programmer to take it and modify the original value.
- In fact, whenever youʼre passing an address into a function, you should make it a const if at all possible

### 6.4 const object

#### 6.4.1 Const member functions

- Cannot modify their objects

```c++
int Date::set_day(int d){
//...error check d here...
day = d; // ok, non-const so can modify
}
int Date::get_day() const {
day++; //ERROR modifies data member
set_day(12); // ERROR calls non-const member
return day; // ok
}
```

- Const member function definition：Repeat the const keyword in the definition **as well as the declaration**

  ```c++
  int get_day () const;
  int get_day() const { return day };
  ```

#### 6.4.2 重载 **const** and none-const functions

```c++
void f() const;
void f();
```

#### 6.4.3 constants in classes

```c++
class HasArray {
const int size;
int array[size]; // ERROR!
};
class HasArray {
enum { size = 100 };
int array[size]; // OK!
};
class HasArray {
static const int size = 100;
int array[size];
}
```

### 6.5 **static**静态

Two basic meanings

- Static storage

- allocated once at a fixed address

  Visibility of a name

  internal linkage

| type                    | meaning                                                      |
| ----------------------- | ------------------------------------------------------------ |
| static free function    | internal linkage(deprecated)                                 |
| static global variables | internal linkage(deprecated)                                 |
| static local variables  | persistent storage                                           |
| static member variables | shared by instances                                          |
| static member functions | static member functions shared by instances, can only access static members |

- **静态局部函数**（static free function ，用 static 显式修饰函数）：在全局命名空间下定义一个只能在**当前编译单元内使用**的静态函数。这种类型的函数拥有内部链接（internal linkage），即只能在当前编译单元内使用，不能被其他编译单元访问，而且它**不作为类成员函数**使用。
- **静态局部变量**（static global variables internal linkage，用 static 显式修饰变量）：在函数内部定义的静态变量不会每次进入函数都创建一次，只会在程序运行期间**初始化一次**，并且其生命周期将持续整个程序执行期间。这些变量拥有内部链接（internal linkage），意味着它们只能在**当前编译单元中使用**。
- **静态数据成员**（static member variables ，用 static 关键字声明类的成员变量）：静态数据成员是针对类定义内的数据成员添加 static 修饰后得到的成员变量。所有该类对象**共享同一份静态数据成员**的副本，即使该类没有被实例化或者有多前的实例化也始终如此。另外，由于这种变量是属于类而不是属于某个对象的，因此它们必须在类定义外部进行**初始化**，而且可以通过 类名::静态成员变量名 来访问。
- **静态成员函数**（static member functions shared by instances, can only access static members，用 static 关键字声明类的成员函数）：静态成员函数是属于类本身而不是属于某个对象的。这种函数不能访问非静态的成员变量或函数，**只能访问被声明为 static 的数据成员**以及其他静态函数。

#### 6.5.1 全局对象（Global objects）

- Constructors are called **before main()** is entered
- Order controlled by appearance in file
- main() is no longer the first function called
- Destructors called when called `main()` `exit()` 

#### 6.5.2 Static Initialization Dependency

使用静态变量时存在 Static Initialization Dependency 问题，简称 SID。这种问题可能会导致程序运行期间出现未定义行为或崩溃等问题。

一般而言，编译器会根据一些规则确定文件静态变量的**初始化顺序**，以避免由于不良的初始化顺序造成程序运行期间的错误。其中一个关键点是：同一编译单元内的所有静态变量构造的顺序是已知的（即按定义的顺序构造），但是**不同编译单元之间的静态变量初始化顺序是未指定**的。 也就是说两个不在同一个源文件的静态全局变量，其初始化到底哪一个先执行是没有明确规定的，具体顺序取决于编译器和链接器的实现细节及操作系统等其他因素。所以，当非本地静态对象（如全局/命名空间范围中声明的静态对象）在不同的文件之间存在依赖时，就会产生错误，这种依赖性也称为跨文件静态初始化顺序问题.

#### 6.5.2 静态成员Static members

Static member variables：

1. Global to all class member functions
2. Initialized once, at file scope
3. provide a place for this variable and init it in .cpp
4. No static in .cpp

- Static member functions：
  - Have no implicit receiver `this `(不依赖对象)
  - Can access only static member variables(or other globals)

### 6.6 Namespace

命名空间（Namespace）是一种将标识符分组的机制。它可以避免全局空间命名冲突，也可以避免不同库间进行命名冲突。

如果没有命名空间，当几个文件都定义了具有**相同名称**的变量或函数时就会产生**冲突**。通过使用命名空间，我们可以将它们分成各个独立的范围来解决这个问题。

- Wrap declarations in namespaces（包装声明）

```c++
// old1.h
namespace old1 {
void f();
void g();
}
// old2.h
namespace old2 {
void f();
void g();
}
```

