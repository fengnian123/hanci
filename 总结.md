# oop

[TOC]

## 第一章、基本介绍

### 1.1 C语言优缺点

优点：

- Efficient programs（程序高效）
- Direct access to machine, suitable for OS and ES（操作底层）
- Flexible（灵活）

缺点：

- Insufficient type checking（类型检查不够）
- Poor support for programming-in-the-large（难以支持大程序）
- Procedure-oriented programming（面向过程）

### 1.2 C++进步

- Data abstraction
- Access control
- Initialization & cleanup
- References
- Function overloading
- Streams for I/O
- Name control
- Operator overloading
- More safe and powerful memory management
- Templates
- Exception handling

### 1.3 字符串

- 字符串是个类（加`#include<string>`）
- `find`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    //主要字符串是从0开始计数的
    cout<<"ab在str中的位置:"<<str.find("ab")<<endl;
    //返回第一次出现ab的位置,没有则返回一串乱码
    cout<<"ab在str[2]到str[n-1]中的位置:"<<str.find("ab",2)<<endl;
    //返回第一次从str[2]开始出现ab的位置,没有则返回一串乱码
    cout<<"ab在str[0]到str[2]中的位置:"<<str.rfind("ab",2)<<endl;
    //返回ab在str[0]到str[2]中的位置,没有则返回一串乱码
    return 0;
}
```

- `substr`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"返回str[3]及其以后的子串:"<<str.substr(3)<<endl;
    //若小于限制长度则报错
    cout<<"从ste[2]开始由四个字符组成的子串:"<<str.substr(2,4)<<endl;
    //若小于限制长度则报错
    return 0;
}
```

- `replace`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string line = "this@ is@ a test string!";
    line = line.replace(line.find("@"), 1, ""); //从第一个@位置替换第一个@为空
    cout<<line<<endl;
    return 0;
}
```

- `insert`函数

```c++
#include <string>
#include <iostream>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"从2号位置插入字符串jkl并形成新的字符串返回:"<<str.insert(2, "jkl")<<endl;
    return 0;
}
```

- `append`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str;
    cin>>str;
    cout<<"在字符串str后面添加字符串ABC:"<<str.append("ABC")<<endl;
    return 0;
}
```

- `swap`函数

```c++
#include <iostream>
#include <string>
using namespace std;
int main()
{
    string str1,str2;
    cin>>str1>>str2;
    cout<<"str1:"<<str1<<endl;
    cout<<"str2:"<<str2<<endl;
    swap(str1, str2);
    cout<<"str1:"<<str1<<endl;
    cout<<"str2:"<<str2<<endl;
}
```

### 1.4 动态内存分配

- 为什么需要动态内存分配？

  存在程序的内存需求只能在**运行时确定**的情况

- 特点：

  1. C++中通过new关键字进行动态内存申请
  2. C++中的动态内存分配是**基于类型**进行的
  3. delete关键字用于内存释放

- new关键字与malloc函数的区别

| new关键字是C++的一部分              | malloc是由C库提供的函数        |
| :---------------------------------- | :----------------------------- |
| new以具体类型为单位进行内存分配     | malloc以字节为单位进行内存分配 |
| new在申请单个类型变量时可进行初始化 | malloc不具备内存初始化的特性   |

例子见https://blog.csdn.net/qq_40416052/article/details/82493916

- Tips：

  Don't use delete to free memory that new **didn't allocate**.

  Don't use delete to free the **same** block of memory twice in succession.

  Use delete [] if new [] was used to allocate an array.

  Use delete (no brackets) if new was used to allocate a single entity.

  It's **safe** to apply delete to the null pointer (nothing happens).

- **`delete`** 运算符的结果类型为 **`void`**，因此它不返回值

- 使用 **`delete`** 释放 C++ 类对象的内存时，将在释放该对象的内存之前调用该对象的析构函数（如果该对象具有析构函数）。

- 如果 **`delete`** 运算符的操作数是可修改的左值，则在删除该对象后未定义其值

- 对于不是类类型（[class](https://learn.microsoft.com/zh-cn/cpp/cpp/class-cpp?view=msvc-170)、[struct](https://learn.microsoft.com/zh-cn/cpp/cpp/struct-cpp?view=msvc-170) 或 [union](https://learn.microsoft.com/zh-cn/cpp/cpp/unions?view=msvc-170)）的对象，将调用**全局 delete** 运算符。 对于类类型的对象，如果 delete 表达式以一元范围解析运算符 (`::`) 开始，则会在全局范围中解析解除分配函数的名称。 否则，delete 运算符将在释放内存之前为对象调用析构函数（如果指针不为 null）。 可为每个类定义 delete 运算符；如果给定类不存在这种定义，则会调用全局 delete 运算符。 如果删除表达式用于释放其静态对象具有虚拟析构函数的类对象，则将通过对象的动态类型的虚拟析构函数解析释放函数。

#### 1.5 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194626209.png" alt="image-20230627194626209" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194715534.png" alt="image-20230627194715534" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194731824.png" alt="image-20230627194731824" style="zoom:67%;" /> 

说反了

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194808174.png" alt="image-20230627194808174" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194831898.png" alt="image-20230627194831898" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194911078.png" alt="image-20230627194911078" style="zoom:67%;" /> 

num1指向其他地方，原来指向的空间没有释放

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195011065.png" alt="image-20230627195011065" style="zoom:67%;" /> 

只收回PAddr的空间

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195407129.png" alt="image-20230627195407129" style="zoom:67%;" /> 

二维指针数组表示三维数组

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195516421.png" alt="image-20230627195516421" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195528298.png" alt="image-20230627195528298" style="zoom:67%;" /> 



## 第二章、Class

### 2.1 引用

- Reference is a new way to manipulate objects in C++：引用引入了对象的一个**同义词**。定义引用的表示方法与定义指针相似，只是用&代替了*。引用（reference）是c++对c语言的**重要扩充**。引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：**类型 &引用变量名 = 已定义过的变量名**。

- 引用的特点：
  1. 一个变量可取**多个**别名。
  2. 引用必须**初始化**。
  3. 引用只能在初始化的时候引用一次 ，**不能更改**为转而引用其他变量。

- Tips：

  1. &在这里不是求地址运算，而是起**标识**作用

  2. 对引用求地址，就是对目标变量求地址。即引用名是目标变量名的一个别名。引用在**定义上**是说引用**不占据任何内存空间**，但是编译器在一般将其实现为**const指针**，即指向位置不可变的指针，所以引用实际上与一般指针同样占用内存

  3. **不能建立引用的数组**。因为数组是一个由若干个元素所组成的集合，所以无法建立一个由引用组成的集合，但是可以建立**数组的引用**
  4. 引用常见的使用用途：作为函数的参数、函数的返回值
  5. Bindings donʼt change at run time（运行时不变）, unlike pointers；Assignment changes the object referred-to

- Pointers vs. References

  References：can't be null（非空）

​                              are dependent on an existing variable, they are an alias for an variable（依赖）

​                              can't change to a new "address" location（不能改）

​        Pointers：can be set to null（可空）

​                         pointer is independent of existing objects（独立）

​                         can change to point to a different address（能改）

- 限制：没有引用的引用；没有指针的引用

```c++
int&* p; // illegal
void f(int*& p);//可以
```



### 2.2 类

#### 2.2.1 `::` resolver

<Class Name>::<function name>
::<function name>

#### 2.2.2 声明和定义

The class declaration, along with the prototype of the member functions should be put
into a **header file**（声明和函数原型放在头文件）
The definition of the member functions should be put into **another source file**（定义放在另一个文件）

#### 2.2.3 this指针

this 是 C++ 中的一个关键字，也是一个 **const 指针**，它指向**当前对象**，通过它可以访问当前对象的所有成员。

this 虽然用在类的内部，但是只有在对象被**创建以后**才会给 this 赋值，并且这个赋值的过程是编译器**自动完成**的，不需要用户干预，用户也**不能**显式地给 this 赋值（const指针）

this 实际上是成员函数的一个**形参**，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是**隐式**的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

this is a natural local variable of all structs member functions that you can not define,but can use it directly.（不能定义，但可以直接使用，自然局部变量）
Inside member functions, you can use this as the pointer to the variable that calls the function.（函数变量的指针）

#### 2.2.4 OOP 特性

1. Everything is an object.
2. A program is a bunch of objects telling each other what to do by sending messages.
3. Each object has its own memory made up of other objects.
4. Every object has a type.
5. All objects of a particular type can receive the same messages.

### 2.3 构造和析构

#### 2.3.1构造函数

- 构造函数是一种特殊的**成员函数**，不需要用户来调用，**定义**对象时被自动执行。
- 构造函数名字**与类名相同**，**无返回类型**。
- 如果我们没有定义构造函数，系统会为我们自动定义一个无参的默认构造函数的，它不对成员属性做任何操作，如果我们自己定义了构造函数，系统就不会为我们创建默认构造函数了。

```c++
struct Y {
float f;
int i;
Y(int a);
};
Y y1[] = { Y(1), Y(2), Y(3) }; // OK
Y y2[2] = { Y(1) }; Y y3[7]; // 错误
Y y4;//错误
```



#### 2.3.2 析构函数

- 析构函数执行对象的**清理**工作，当对象的生命周期结束的时候，会自动调用。析构函数的作用并不是删除对象，在对象撤销它所占用的内存之前，做一些清理的工作。清理之后，这部分内存就可以被系统回收再利用了。在设计这个类的时候，系统也会默认的提供一个析构函数。在对象的生命周期结束的时候，程序就会自动执行析构函数来完成这些工作。同构造函数，用户自己定义，系统自动调用。

```c++
class Y {
public:
~Y();
};
```

- 析构函数没有返回值，**没有参数**；
- 没有参数，所以**不能重载**，一个类仅有一个析构函数；
- 析构函数除了释放工作，还可以做一些用户希望它做的一些工作，比如输出一些信息
- 调用时间：当对象**超出作用域**时，编译器自动调用析构函数。例如：main函数里创建对象，在退出main函数之后，析构函数被调用。在main函数的外面创建的对象，这个对象的销毁是在我们退出程序之后。析构函数销毁对象的顺序与构建对象的顺序是**相反**的。因为对象的存储是在**栈**中的，栈的特性就是先进后出。

#### 2.3.4 存储分配

- The compiler allocates all the storage for a scope at the opening brace of that scope.（在作用域的开始大括号处为该作用域分配所有存储空间）
- The constructor call doesnʼt happen until the sequence point where the object is defined

#### 2.4 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195642047.png" alt="image-20230627195642047" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195705963.png" alt="image-20230627195705963" style="zoom:67%;" /> 

缺省=默认，所以是私有

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195821370.png" alt="image-20230627195821370" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195834732.png" alt="image-20230627195834732" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195850372.png" alt="image-20230627195850372" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195907034.png" alt="image-20230627195907034" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627195928285.png" alt="image-20230627195928285" style="zoom:67%;" /> .

。。。



## 第三章 类和对象

### 3.1类的定义

#### 3.1.1 编译单元

- The compiler sees only one .cpp file, and generates .obj file
- The linker links all .obj into one executable file
- To provide information about functions in other .cpp files, use .h

#### 3.1.2 头文件

- If a function is declared in a header file, you must include the header file **everywhere**

- If a class is declared in a header file, you must include the header file everywhere the class is used and where class member functions are defined
- Header = interface
  The header is a **contract** between you and the user of your code.
  The compiler enforces the contract by requiring you to declare all structures and functions before they are used.

- 内容：extern variables；function prototypes；class/struct declaration

- 形式：

  `#include`:include is to **insert** the included file into the .cpp file at where the #include

  statement is.

  `include "xx.h" `: search in the **current directory** firstly, then the directories declared somewhere（优先找当前文件夹）

  `include <xx.h>` : search in the **specified** directories

  `include <xx>` : same as include <xx.h>



## 第四章、容器

### 4.1 STL（标准模板库）

#### 4.1.1 优点

- Reduce development time.– Data-structures already written and debugged.
- Code readability（可读性）
- Fit more meaningful stuff on one page（紧凑）
- Robustness– STL data structures grow automatically.（自动增长）
- Portable code；Maintainable code（可移植，可维护）
- Easy

#### 4.1.2 模板库内容:

- A Pair class (pairs of anything, int/int, int/char, etc)
- Containers：Vector (expandable array)；Deque (expandable array, expands at both ends)；List (double-linked)；Sets and Maps
- Basic Algorithms (sort, search, etc)
- All identifiers in library are in std namespace: using namespace std;

#### 4.1.3 vector

- It is able to **increase its internal capacity** as required: as more items are added, it simply makes enough room for them.（自动增长的内存）
- It keeps its own private count of how many items it is currently storing.   Its size method returns the number of objects currently stored in it.（统计有多少项，`.size()`函数返回个数）
- It maintains the order of items you insert into it.   You can later retrieve them in the same order（顺序储存）

函数：

```c++
v.assign(2, 3);//将 2 个 3 赋值给 v
v.swap(v1);//交换两个容器的内容
v.push_back(4);//在末尾添加元素 4
v.pop_back();//删除最后一个元素
v.front();//返回第一元素
v.back();//返回最末元素
v.clear();//清空容器
v.empty();//容器为空返回true, 否则返回 false
```

初始化方式：

```c++
vector<int> v(100);//预先定义
v[80]=1; // okay
v[200]=1; // bad

vector<int> v2;//自动增长
int i;
while (cin >> i)
v.push_back(i);
```

#### 4.1.4 list

- 用法和vector等容器基本相同, 但是内部结构区别很大

函数：

```c++
l.push_front(3);//在头部插入元素 3
l.push_back(3);//在末端插入元素 3
l.pop_front();//删除第一元素
l.pop_back();//删除最末元素
l.front();//返回第一元素
l.back();//返回最末元素
l.clear();//清空容器
l.empty();//容器为空返回 true, 否则返回 false
```

#### 4.1.5 map

- Maps are collections that contain pairs of values.（一对值）
- Pairs consist of a key and a value.（键值与值的映射）
- Lookup works by supplying a key, and retrieving a value.

#### 4.1.6 stl的使用

- `vector<Student> v1;`：定义了一个存储 `Student` 类型对象的 vector 容器，对象直接保存在容器`vector<Student&> v2;`：定义了一个存储 `Student` 类型的引用的 vector 容器，但是由于引用类型不能被拷贝和赋值，所以这种写法不符合语法规范。

  `vector<Student*> v3;`：定义了一个存储指向 `Student` 类型对象的指针的 vector 容器，即对象的地址保存在容器中。

### 4.2 Iterators

- Declaring

  ```c++
  list<int>::iterator li;
  list<int> L;
  li = L.begin();//Front of container
  li = L.end();//Past the end
  ```

- 迭代器都可以进行`++`操作。反向迭代器和正向迭代器的区别在于：

  - 对正向迭代器进行`++`操作时，迭代器会指向容器中的后一个元素；
  - 而对反向迭代器进行`++`操作时，迭代器会指向容器中的前一个元素。

- 正向迭代器:假设 p 是一个正向迭代器，则 p 支持以下操作：++p，p++，*p。此外，两个正向迭代器可以**互相赋值**，还可以用`==`和`!=`运算符进行**比较**。
- 双向迭代器:双向迭代器具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则`--p`和`p--`都是有定义的。`--p`使得 p 朝和`++p`相反的方向移动。

### 4.3 Algorithms

- Advantages of foreach loop:

  It eliminates the possibility of errors and makes the code more readable.(不会错)

  Easy to implement（可读性）

  Does not require pre-initialization of the iterator（不用初始化迭代器）

- Disadvantages of foreach loop:

  Cannot directly access the corresponding element indices（不能直接访问元素）

  Cannot traverse the elements in reverse order（无法逆序）

  It doesnʼt allow the user to skip any element as it traverses over each one of them（无法跳过）

### 4.4 Typdefs

- Annoying to type long names,like:

  ```c++
  typedef PB map<Name,list<PhoneNum> >;
  PB phonebook;
  PB::iterator finger;
  ```

  Easy to change implementation.

### 4.5 Pitfalls

- Accessing an invalid

  ```c++
  vector<int> v;
  v[100]=1; // 不一定能取到
  ```

  Solutions:

  - use push_back()
  - Preallocate with constructor.（预先分配空间）
  - Reallocate with reserve()（重新分配内存）
  - Check capacity()

- Use invalid iterator

```c++
list<int> L;

list<int>::iterator li;

li = L.begin();

L.erase(li);

++li; // WRONG

// Use return value of erase to advance

li = L.erase(li); // RIGHT
```

### 4.6 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200051257.png" alt="image-20230627200051257" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200109340.png" alt="image-20230627200109340" style="zoom:67%;" /> 

当执行 `v.push_back("ZUCC");` 时，如果 vector 容器的大小不足以容纳新元素，则会动态分配更多的空间，并将新元素插入到容器的末尾。这种情况下，会调用字符串类的拷贝构造函数来创建一个临时字符串对象，然后将其插入 vector 中

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200233829.png" alt="image-20230627200233829" style="zoom:67%;" /> 

循环结束后，`std::map m` 中实际上只有一个元素，即最后一个读入的字符串作为键，并且它的值为9。因此输出的 `m.size()` 结果为1。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200402634.png" alt="image-20230627200402634" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200418791.png" alt="image-20230627200418791" style="zoom:67%;" /> 

`vector<int> v(10, 1);` 的意思是创建了一个包含 10 个元素的整数向量 `v`，并将每个元素初始化为 1

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200639533.png" alt="image-20230627200639533" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200651193.png" alt="image-20230627200651193" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200712013.png" alt="image-20230627200712013" style="zoom:67%;" /> 

引用初始化不能用表达式，const做右值左边一定也是const

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627200934085.png" alt="image-20230627200934085" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201029267.png" alt="image-20230627201029267" style="zoom:67%;" /> 

能将引用绑定到无法修改的临时值或字面量上。

## 第五章、Functions

### 5.1 局部变量

Local variables are defined **inside a method**, have a scope limited to the method to which they belong.

- 如果一个局部变量和类的成员变量(字段)拥有相同的名字，这样会导致方法内部无法直接访问这个字段。这是因为，当编译器遇到这样的情况时，它会默认使用局部变量而不是类成员变量。这种现象被称为"名称遮掩（Name Hiding）"。

  例如，假设我们定义了一个名为 `Foo` 的类，并在其中声明了一个整型成员变量 `value`：

  ```c++
  class Foo {
  public:
    int value;   // 成员变量（字段）
    void bar() {
      int value = 42;   // 局部变量
      // ...
    }
  };
  ```

  在上面例子中，`bar()`函数内部定义了一个局部变量`value`来存放值为42的整数，此时如果需要在该函数中访问`value`成员变量，就会产生名称遮掩，即编译器会自动**取局部变量**而非class的成员`value`。

- Fields（成员变量）, parameters, local variables比较：

1. Fields：成员变量是定义在**类或结构体中**的变量，在**实例化**该类或结构体时会**被创建**。成员变量可以被整个类内的函数所使用，同时也可以被类的外部所访问，并且成员变量的值在整个**类的生存期**内都是存在的。
2. Parameters：函数参数是在调用函数时传递给该函数的一组值。它们只在函数内部起作用，并且在函数**执行完成后就被销毁**了。
3. Local Variables：局部变量是在函数内部定义的变量。与函数参数一样，它们也只在函数内部起作用，并且在函数结束时就会销毁。
4. Fields are defined outside constructors and methods
5. Formal parameters are defined in the header of a constructor or method.     They receive their values from outside, being initialized by the actual parameter values that form part of the constructor or method call（传参的时候由特定的构造函数初始化形参）

### 5.2 C++ access control

#### 5.2.1 访问形式

通过使用访问修饰符来限制类成员变量或函数的可见性。C++ 共有三种形式的访问控制：public、private 和 protected。

- Public：公共的成员变量和函数可以被类的任何地方的代码所访问，包括该**类的对象、子类、其他非子类**等。
- Private：私有的成员变量和函数只能由包含它们的**类本身所访问**，其他任何类型的对象都无法直接访问。继承自该类的子类及其他任何类都无法访问这些成员。
- Protected：受保护的成员变量和函数和私有成员一样，不能被类外部的代码直接访问，但是可以被继承自该类的**子类所访问**。而其他非子类的代码仍然不能访问。

- **默认情况**下，C++ 类定义的成员变量和成员函数的访问级别为 `private`

#### 5.2.2 Friends

可以通过友元函数或友元类(friends)来实现某些函数或类对于其他类的**私有/受保护成员的访问**。友元是一种特殊的访问修饰符，与`public`, `private`, 和 `protected`不同。

```c++
class MyClass {
 private:
  int myVar;
  // 友元类能够访问该类的私有成员
  friend class MyFriendClass;
     // 友元函数能够访问该类的私有成员
  friend void setMyVar(MyClass &obj, int val);
};
void setMyVar(MyClass &obj, int val) {
  obj.myVar = val;   // 在友元函数中设置私有成员变量的值
}
class MyFriendClass {
 public:
  void setMyVar(MyClass &obj, int val) {
    obj.myVar = val;   // 从友元类中设置私有成员变量的值
  }
};
int main() {
  MyClass obj;
  MyFriendClass frd;
  frd.setMyVar(obj, 42);   // 在main函数中使用friend类设定值
  return 0;
}
```

#### 5.2.3 class vs. struct

- class defaults to private

- struct defaults to public.

### 5.3 Initialization

#### 5.3.1 初始化列表

初始化列表是用于定义类构造函数时指定初始值的一种方式。初始化列表也可以用于结构体和联合体初始化

当对象创建时，成员变量的初始化被放在它们的申明中或者在构造函数内部。如果我们直接在构造函数中通过赋值语句来初始化成员变量，那么就会多出一个**额外的步骤**：首先调用默认构造函数来初始化这些成员变量，然后再用指定的表达式进行覆盖复制。

- pseudo-constructor calls for built-ins(用内置函数的伪构造函数调用)

- Order of initialization is order of declaration – Not the order in the list（类成员变量的初始化顺序始终按照它们在类中声明的顺序进行，而不是在构造函数初始化列表中指定的顺序）

- Destroyed in the reverse order.（销毁顺序**相反**）

- Initialization vs. assignment

  ```c++
  Student::Student(string s):name(s) {}//initialization
  ```

  before constructor

  ```c++
  Student::Student(string s) {name=s;}//assignment
  ```

  inside constructor

  string must have a default constructor

#### 5.3.2 Overloaded constructors

可以为一个类定义多个不同的构造函数，这些构造函数使用相同的名称但带有**不同的参数列表**。

- 可以为参数提供**默认值**。如果调用该函数时**省略**了默认参数，则将使用预定义的默认值来**自动初始化**参数。

  下面是默认参数规则的几个要点：

  1. **默认参数必须出现在函数声明中的非默认参数之后**，即所有有默认值的参数都在末尾，否则编译器会报错。
  2. 函数调用时，如果有缺省参数，那么可以不传递该参数，并按照函数原型中所列出的默认值赋值，例如：`myFunction();`
  3. 可以直接跳过某个有默认值的参数并在调用时给定其后面的参数，例如：`myFunction(42);`
  4. 在声明函数时，可以指定参数的默认值。示例代码如下：

  ```c++
  int myFunction(int x, int y=5, bool z=true) 
  int chico(int n, int m = 6, int j);//illeagle
  int result1 = myFunction(10);          //y被隐式设置为5， z被隐式设置为true
  int result2= myFunction(10,20,false); //y被设置为20，z被设置为false
  ```

#### 5.3.3 Pitfall of default arguments

- The default arguments are declared in its prototype, not defined in its function head：Can not put default arguments in definition（默认参数只需要在函数原型或者函数声明中提供，而**不需要**在函数定义中再次列出）

```c++
// 非法：定义中不应该有默认参数
void myFunction(int a=0, int b) { ... }
// 非法：同时出现了函数声明和定义中的默认参数
void myFunction(int a=0, int b=5) {
  ...
}
// 非法定义例子，超过了函数原型的作用域范围
void myFunction(int a, int b=5) { 
  // 函数原型/outside的默认b=5.
  ...
  void innerFunction(int x, int y=b); // error-不能使用外部函数的默认参数
  ...
}

```

### 5.4 inline function

内联（inline）函数是一些较小的函数，通常包含少量语句并不需要执行长时间运算。其实现过程是，编译器会将 "内联函数" 的代码**插入**到程序中的每个调用处，而**不是实际上去创建该函数**，并在程序执行时动态调用它，从而节省了函数调用本身所需的时间

- Repeat inline keyword at declaration and definition.

- An inline function definition may not generate any code in .obj file.

- So you can put inline functionsʼ bodies in **header file**. Then #include it where the function is needed.

  Never be afraid of multi-definition of inline functions, Definitions of inline functions are just **declarations.**

- The compiler does not have to honor your request to make a function inline. It might

  decide the function is too large or notice that it calls itself (recursion is not allowed or

  indeed possible for inline functions), or the feature might not be implemented for your

  particular compiler（编译器自己判断是否内联，递归或过大就不内联）

  

  Any function you define inside a class declaration is automatically an inline（类里定义的函数自动变成内联函数）

- You can put the definition of an inline member function out of the class braces.

  But the definition of the functions should be put before where they may be called.（编译器必须能够看到内联函数的函数体，否则就无法展开该函数的实现代码）

### 5.5 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201405784.png" alt="image-20230627201405784" style="zoom:67%;" /> 

空间复杂度增加

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201435323.png" alt="image-20230627201435323" style="zoom:67%;" />

编译器决定

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201457469.png" alt="image-20230627201457469" style="zoom:67%;" /> 

默认参数必须出现在函数声明中的非默认参数之后

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201554954.png" alt="image-20230627201554954" style="zoom:67%;" /> 

《返回类型》

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201626182.png" alt="image-20230627201626182" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201643932.png" alt="image-20230627201643932" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201718483.png" alt="image-20230627201718483" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201730538.png" alt="image-20230627201730538" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201740884.png" alt="image-20230627201740884" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201810986.png" alt="image-20230627201810986" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201831831.png" alt="image-20230627201831831" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201849680.png" alt="image-20230627201849680" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201904350.png" alt="image-20230627201904350" style="zoom:67%;" /> 

一眼丁真

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201926113.png" alt="image-20230627201926113" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627201946802.png" alt="image-20230627201946802" style="zoom:67%;" /> 



## 第六章、常量

### 6.1 const关键字

declares a variable to have a **constant** value

```c++
const int x = 123;
x = 27; // illegal!
x++; // illegal!
int y = x; // Ok, copy const to non-const
y = x; // Ok, same thing
const int z = y; // ok, const is safer
```

- Constants are variables，observe scoping rules（常量是一种变量，因此遵守作用域法则）
- the compiler tries to avoid creating storage for a const -- holds the value in its symbol table.（编译器不给常量空间，使用 `extern` 强制分配存储空间）
- 必须初始化，除非用`extern`

Compile time constants

```c++
const int bufsize = 1024;//value must be initialized
extern const int bufsize;
```

#### 6.1.1 Run-time constants

数组的长度必须是一个常量表达式(constant expression)，也就是说，在编译时可以确定的一个常量值。因此，在定义数组时，我们不能使用**运行时变量**来指定数组的长度。

```c++
const int class_size = 12;
int finalGrade[class_size]; // ok
int x;
cin >> x;
const int size = x;
double classAverage[size]; // error!
```

#### 6.1.2 聚合（Aggregates）

聚合（Aggregate）是指一些简单的数据类型的集合。聚合类型具有以下特性：

1. 是一个类或结构体；
2. 没有用户自定义的构造函数、析构函数和赋值运算符重载；
3. 所有成员都是 public 的；
4. 没有虚函数；

- Itʼs possible to use const for aggregates, but storage will be allocated. In these situations, const means a piece of storage that **cannot be changed.**

  However, the value cannot be used at compile time because the compiler is not required to know the contents of the storage at compile time（可以使用 `const` 关键字将聚合类型定义为常量，使其分配存储空间并不能够更改其值。但是在编译时，因为编译器无法知道其内容，所以不能将其用于数组大小或结构体成员的初始化参数等需要在编译时执行的地方。）

```c++
const int i[] = { 1, 2, 3, 4 };
float f[i[3]]; // Illegal
struct S { int i, j; };
const S s[] = { { 1, 2 }, { 3, 4 } };
double d[s[1].j]; // Illegal
```

#### 6.2 Pointers and const

指针（Pointers）和 `const` 常量（Constants）可以结合使用，`const` 关键字可以应用于指针本身或指针所指向的对象。具体来说，如果是将 `const` 应用于**指针本身**，则表示该指针变量**本身不能被更改**；而如果是将 `const` 应用于指针所指向的**对象**，则表示该**对象不能被修改**。

```c++
char * const q = "abc"; // q is const
*q = 'c'; // OK
q++; // ERROR
const char *p = "ABCD"; // (*p) is a const char
*p = 'b'; // ERROR! (*p) is the const
```

|                | **int i;** | **const int ci = 3;** |
| -------------- | ---------- | --------------------- |
| int *ip;       | ip = &i;   | ip = &ci; // ERROR    |
| const int *cip | cip = &i;  | cip = &ci;            |

```c++
*ip = 54; // always legal since ip points to int
*cip = 54; // never legal since cip points to const int
```

#### 6.2.1 String Literals

```c++
char* s = "Hello, world!";
```

- This is actually a **const char *s** but compiler accepts it without the const
- If you want to change the string, put it in an **array**

#### 6.2.2 Conversions

- Can always treat a non-const value as const
-  cannot treat a constant object as non-constant without an explicit cast

```c++
void f(const int* x);
int a = 15;
f(&a); // ok
const int b = a;
f(&b); // ok
b = a + 1; // Error!
```

### 6.3 Passing and returning addresses

- Passing a whole object may cost you a lot. It is better to pass by a pointer. But itʼs possible for the programmer to take it and modify the original value.
- In fact, whenever youʼre passing an address into a function, you should make it a const if at all possible

6.4 const object

#### 6.4.1 Const member functions

- Cannot modify their objects

```c++
int Date::set_day(int d){
//...error check d here...
day = d; // ok, non-const so can modify
}
int Date::get_day() const {
day++; //ERROR modifies data member
set_day(12); // ERROR calls non-const member
return day; // ok
}
```

- Const member function definition：Repeat the const keyword in the definition **as well as the declaration**

  ```c++
  int get_day () const;
  int get_day() const { return day };
  ```

#### 6.4.2 重载 **const** and none-const functions

```c++
void f() const;
void f();
```

#### 6.4.3 constants in classes

```c++
class HasArray {
const int size;
int array[size]; // ERROR!
};
class HasArray {
enum { size = 100 };
int array[size]; // OK!
};
class HasArray {
static const int size = 100;
int array[size];
}
```

#### 6.5 **static**静态

Two basic meanings

- Static storage

- allocated once at a fixed address

  Visibility of a name

  internal linkage

| type                    | meaning                                                      |
| ----------------------- | ------------------------------------------------------------ |
| static free function    | internal linkage(deprecated)                                 |
| static global variables | internal linkage(deprecated)                                 |
| static local variables  | persistent storage                                           |
| static member variables | shared by instances                                          |
| static member functions | static member functions shared by instances, can only access static members |

- **静态局部函数**（static free function ，用 static 显式修饰函数）：在全局命名空间下定义一个只能在**当前编译单元内使用**的静态函数。这种类型的函数拥有内部链接（internal linkage），即只能在当前编译单元内使用，不能被其他编译单元访问，而且它**不作为类成员函数**使用。
- **静态局部变量**（static global variables internal linkage，用 static 显式修饰变量）：在函数内部定义的静态变量不会每次进入函数都创建一次，只会在程序运行期间**初始化一次**，并且其生命周期将持续整个程序执行期间。这些变量拥有内部链接（internal linkage），意味着它们只能在**当前编译单元中使用**。
- **静态数据成员**（static member variables ，用 static 关键字声明类的成员变量）：静态数据成员是针对类定义内的数据成员添加 static 修饰后得到的成员变量。所有该类对象**共享同一份静态数据成员**的副本，即使该类没有被实例化或者有多前的实例化也始终如此。另外，由于这种变量是属于类而不是属于某个对象的，因此它们必须在类定义外部进行**初始化**，而且可以通过 类名::静态成员变量名 来访问。
- **静态成员函数**（static member functions shared by instances, can only access static members，用 static 关键字声明类的成员函数）：静态成员函数是属于类本身而不是属于某个对象的。这种函数不能访问非静态的成员变量或函数，**只能访问被声明为 static 的数据成员**以及其他静态函数。

#### 6.5.1 全局对象（Global objects）

- Constructors are called **before main()** is entered
- Order controlled by appearance in file
- main() is no longer the first function called
- Destructors called when called `main()` `exit()` 

#### 6.5.2 Static Initialization Dependency

使用静态变量时存在 Static Initialization Dependency 问题，简称 SID。这种问题可能会导致程序运行期间出现未定义行为或崩溃等问题。

一般而言，编译器会根据一些规则确定文件静态变量的**初始化顺序**，以避免由于不良的初始化顺序造成程序运行期间的错误。其中一个关键点是：同一编译单元内的所有静态变量构造的顺序是已知的（即按定义的顺序构造），但是**不同编译单元之间的静态变量初始化顺序是未指定**的。 也就是说两个不在同一个源文件的静态全局变量，其初始化到底哪一个先执行是没有明确规定的，具体顺序取决于编译器和链接器的实现细节及操作系统等其他因素。所以，当非本地静态对象（如全局/命名空间范围中声明的静态对象）在不同的文件之间存在依赖时，就会产生错误，这种依赖性也称为跨文件静态初始化顺序问题.

#### 6.5.2 静态成员Static members

Static member variables：

1. Global to all class member functions
2. Initialized once, at file scope
3. provide a place for this variable and init it in .cpp
4. No static in .cpp

- Static member functions：
  - Have no implicit receiver `this `(不依赖对象)
  - Can access only static member variables(or other globals)

### 6.6 Namespace（看成一个类就行，，）

命名空间（Namespace）是一种将标识符分组的机制。它可以避免全局空间命名冲突，也可以避免不同库间进行命名冲突。

如果没有命名空间，当几个文件都定义了具有**相同名称**的变量或函数时就会产生**冲突**。通过使用命名空间，我们可以将它们分成各个独立的范围来解决这个问题。

作用： 

- 表示类、函数、变量等的逻辑分组（Expresses a logical grouping of classes, functions, variables, etc.）
- 名称空间是一个类似于类的作用域（A namespace is a scope just like a class）
- 仅在需要名称封装时使用（Preferred when only name encapsulation is needed）

```c++
// old1.h
namespace old1 {
void f();
void g();
}
// old2.h
namespace old2 {
void f();
void g();
}

namespace A {
    int a = 100;
}
namespace B {
    int a = 200;
}
void test02()
{
    //A::a  a是属于A中
    cout<<"A中a = "<<A::a<<endl;//100
    cout<<"B中a = "<<B::a<<endl;//200
}
```

- 命名空间只能全局范围内定义（以下为**错误写法**）

```c++
void test02()
{	
    namespace A {//不能局部定义
    int a = 100;
}
    namespace B {
    int a = 200;
}
    //A::a  a是属于A中
    cout<<"A中a = "<<A::a<<endl;//100
    cout<<"B中a = "<<B::a<<endl;//200
}
```

- 命名空间中的函数 可以在“命名空间”外定义

```c++
namespace A {
    int a=100;//变量
 
    void func();
}
 
void A::func()//成员函数 在外部定义的时候记得加作用域
{
    //访问命名空间的数据不用加作用域
    cout<<"func遍历a = "<<a<<endl;
}
 
void funb()//普通函数
{
    cout<<"funb遍历a = "<<A::a<<endl;
}
void test06()
{
   A::func();
    funb();
}
```

- 无名命名空间，意味着命名空间中的标识符只能在本文件内访问，相当于给这个标识符加上了static，使得其可以作为内部连接（等于正常写变量和函数）

```c++
namespace{
    int a = 10;
    void func(){
        cout<<"hello namespace"<<endl;
    }
}
void test(){
    //只能在当前源文件直接访问a 或 func
    cout<<"a = "<<a<<endl;
    func();
}
```

Using的用法

- Introduces a local synonym for name（把命名空间里的东西用一个同名的东西代替）
- States in one place where a name comes from（在一个地方说明，其他地方不用再说）
- Eliminates redundant scope qualification（减少冗余的限定符书写）

```c++
void main() {
using MyLib::foo;
using MyLib::Cat;
foo();
Cat c;
c.Meow();
}
```

Using-Directives

- Makes all names from a namespace available.
- Can be used as a notational convenience.

```c++
void main() {
using namespace std;
using namespace MyLib;
foo();
Cat c;
c.Meow();
cout << "hello" << endl;
}
```

Ambiguities（Using-Directives可能出现歧义）

- Using-directives only make the names available.
- Ambiguities arise only when you make calls.（调用时出现歧义）
- Use scope resolution to resolve.（加：：）

```c++
// Mylib.h
namespace XLib {
void x();
void y();
}
namespace YLib {
void y();
void z();
}

void main() {
using namespace XLib;
using namespace YLib;
x(); // OK
y(); // Error: ambiguous
XLib::y(); // OK, resolves to XLib
z(); // OK
}
```



Namespace aliases（别名）

- Namespace names that are too short may clash（太短可能冲突）
- names that are too long are hard to work with（太长不方便用）
- Use aliasing to create workable names（用一个短的别名）
- Aliasing can be used to version libraries.（别名还可以用于对库进行版本控制。当更新库的新版本时，我们可以使用别名来引用特定的版本，从而确保代码与所需的库版本匹配。这样可以提供更多灵活性，并避免由于库的升级而导致的潜在问题。）

```c++
namespace supercalifragilistic {
void f();
}
namespace short = supercalifragilistic;
short::f();
```



Namespace composition（类似于类的组合）

- Compose new namespaces using names from other ones.
- Using-declarations can resolve potential clashes.（组合的命名空间里相同的东西要声明用哪个里面的，这个是必须的，而且应该是运行时会出错<可能是动态链接的>，你如果不调用这个重复的东西什么都不会发生，但是调用了之后直接报错）
- Explicitly defined functions take precedence.（明确定义的函数会覆盖其他命名空间中相同名称的函数）

```c++
namespace first {
void x();
void y();
}
namespace second {
void y();
void z();
}
namespace mine {
using namespace first;
using namespace second;
using first::y(); // resolve clashes to first::x()
void mystuff();
// ...
}
```

Namespace selection（选择用哪些东西，没什么可说）

```c++
namespace mine {
using orig::Cat; // use Cat class from orig
void x();
void y();
}
```

Namespaces are open（不同文件里定义相同的命名空间，然后就十分智能地把它们里面的东西合一起了）

```c++
//header1.h
namespace X {
void f();
}
// header2.h
namespace X {
void g(); // X how has f() and g();
}
```

### 6.7 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202237075.png" alt="image-20230627202237075" style="zoom:67%;" /> 

和列表的顺序无关，要看声明顺序

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202418011.png" alt="image-20230627202418011" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202355478.png" alt="image-20230627202355478" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202455688.png" alt="image-20230627202455688" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202516723.png" alt="image-20230627202516723" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202617388.png" alt="image-20230627202617388" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202635941.png" alt="image-20230627202635941" style="zoom:67%;" /> .

友元关系不能继承

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202729980.png" alt="image-20230627202729980" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202756420.png" alt="image-20230627202756420" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202810304.png" alt="image-20230627202810304" style="zoom:67%;" /> 

可以访问私有成员的东西：成员函数、友元、友元类的成员函数

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202904048.png" alt="image-20230627202904048" style="zoom:67%;" /> 

全局的，不属于某个对象，自然没有this

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627202936826.png" alt="image-20230627202936826" style="zoom:67%;" /> 

所有类的对象共享一个静态变量

## 第七章 继承（Inheritance）

### 7.1 组合（Composition）

Composition: construct new object with existing objects（It is the relationship of **has-a**）

- Objects can be used to build up other objects
- 可以全组合，也可以组合一部分

```c++
class Person { 
public:
    Person(){};
    Person(string name, string address){
        this->name=name;
        this->address=address;
    }
    void set_name(string name){
        this->name=name;
    }
    void set_address(string address){
        this->name=address;
    }
    void print(){
        cout<<name<<address<<endl;
    }
private:
    string name;
    string address;
 };
class Currency { 
public:
    void set_cents( int cents ){
        num=cents;
    }
    void print(){
        cout<<num<<endl;
    }
private:
    int num;
};
class SavingsAccount {
public:
SavingsAccount(
        const string name,
        const string address,
        int cents );
    ~SavingsAccount(){};
    void print();
private:
    Person m_saver;
    Currency m_balance;
};


SavingsAccount::SavingsAccount (
        const string name,
        const string address,
        int cents ) {
    m_saver.set_name( name );
    m_saver.set_address( address );
    m_balance.set_cents( cents );
}
void SavingsAccount::print() {
    m_saver.print();
    m_balance.print();
}
```

### 7.2 Inheritance

Inheritance is to take the existing class, clone it, and then make additions and modifications to the clone（继承是获取现有的类，克隆后进行添加和修改。）

- Allows sharing of design for
  1. Member data
  2. Member functions
  3. Interfaces
- Advantages of inheritance
  1. Avoiding code duplication
  2. Code reuse （重用但不重复）
  3. Easier maintenance （维护性）
  4. Extendibility （扩展性）
- 继承的构造
  - Think of inherited traits as an embedded object
  - Base class is mentioned by class name

```c++
class Employee {
public:
    Employee( const std::string& name, const std::string& ssn );
        const std::string& get_name() const;
    void print(std::ostream& out) const;
    void print(std::ostream& out, const std::string& msg) const;
protected:
    std::string m_name;
    std::string m_ssn;
};
Employee::Employee( const string& name, const string& ssn )
: m_name(name), m_ssn( ssn) {
// initializer list sets up the values!
}
inline const std::string& Employee::get_name() const {
    return m_name;
}
inline void Employee::print( std::ostream& out ) const {
    out << m_name << endl;
    out << m_ssn << endl;
}
inline void Employee::print(std::ostream& out, const std::string& msg) const {
    out << msg << endl;
    print(out);
}
//下面是寄存类
class Manager : public Employee {
public:
    Manager(const std::string& name, const std::string& ssn, const std::string& 	title);
    const std::string title_name() const;
    const std::string& get_title() const;
    void print(std::ostream& out) const;
private:
    std::string m_title;
};
Manager::Manager( const string& name, const string& ssn, const string& title = "" )
:Employee(name, ssn), m_title( title ) {
}
inline void Manager::print( std::ostream& out ) const {
    Employee::print( out ); // call the base class print
    out << m_title << endl;
}
inline const std::string& Manager::get_title() const {
    return m_title;
}
inline const std::string Manager::title_name() const {
	return string( m_title + ": " + m_name ); // access base m_name
}
```

- More on constructors
  - Base class is always constructed first（基类先构造）
  - If no explicit arguments are passed to base class，Default constructor will be called
  - Destructors are called in exactly the reverse order of the constructors（析构顺序相反）

- Name Hiding

  If you redefine a member function in the derived class, all other overloaded functions

  in the base class are inaccessible.(在继承类中重新定义基类的函数，基类的函数无法访问)

- What is not inherited

  Constructors

  - synthesized constructors use memberwise initialization（在合成的构造函数中，成员按逐个成员的方式进行初始化）
  - In explicit copy ctor, explicity call base-class copy ctor or the default ctor will becalled instead.（在显式定义的拷贝构造函数中，我们可以明确调用基类的拷贝构造函数，确保正确复制派生类和基类的数据。）

  Destructors

  Assignment operation

  - synthesized operator= uses memberwise assignment
  - explicit operator= be sure to explicity call the base class version of operator=

  Private data is hidden, but still present（也继承了）

- Access protection

  - 默认继承方式是私有继承

  - | Inheritance Type (B is) | public（不变） | protected（最多保护） | private（全为私有） |
    | ----------------------- | -------------- | --------------------- | ------------------- |
    | public A                | public in B    | protected in B        | hidden              |
    | private A               | private in B   | private in B          | hidden              |
    | protected A             | protected in B | protected in B        | hidden              |

- When is protected not protected?

  - When your derived classes are ill-behaved!

  - Protected is public to all derived classes（`protected` 是对所有派生类公开的）

  因此

  - make member functions protected（成员函数可以被自己的子类(派生类)直接访问,不被外部直接访问）

  - keep member variables private

- Subclasses and subtyping

  - Objects of subclasses can be used where objects of supertypes are required（子类的对象可以用于需要父类的参数，“IS—A”，需要一个动物，给你一个狗，这种做法叫 substitution）
  - Subclass object may be assigned to superclass pointr variables

  ```c++
  Vehicle *v1 = new Vehicle();
  Vehicle *v2 = new Car();
  Vehicle *v3 = new Bicycle();
  public class Database
  {
      public void addItem(Item &theItem)
      {
          ...
      }
  }
  DVD dvd = new DVD(...);
  CD cd = new CD(...);
  database.addItem(dvd);
  database.addItem(cd);
  ```

- Up-casting（向上转型）

  - Is to regard an object of the derived class as an object of the base class（把子类看成基类）
  - Upcasting is the act of converting from a Derived reference or pointer to a base class reference or pointer.（将子类对象指针或引用赋值给父类指针或引用）

  ```c++
  class Animal {
  public:
      virtual void makeSound() {
          cout << "Animal is making a sound" << endl;
      }
  };
  class Dog : public Animal {
  public:
      void makeSound() override {
          cout << "Dog is barking" << endl;
      }
  };
  int main() {
      Dog dog;
      Animal* animalPtr = &dog;  // Up-casting，将Dog对象指针赋值给Animal指针
      animalPtr->makeSound();    // 调用的是Dog的重写函数
  }
  ```

- Static type and dynamic type

  - 静态类型（Static Type）：指的是在编译时就确定下来的变量或表达式的类型
  - 动态类型（Dynamic Type）：指的是在运行时确定的变量或表达式的类型（引出多态）

### 7.3 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624161950024.png" alt="image-20230624161950024" style="zoom: 50%;" /> 

一眼丁真

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624162029136.png" alt="image-20230624162029136" style="zoom:50%;" /> 

super class就是父类 

```c++
#include <iostream>
#include <string>
using namespace std ;
class Testing
{
private:
    string words; 
    int number ;
public:
    Testing(const string & s = "Testing")
    {
        words = s ;
        number = words.length();
        if (words.compare("Testing")==0)
            cout << 1;
        else if (words.compare("Heap1")==0)
            cout << 2;
        else
            cout << 3;
    }
    ~Testing()
    {
        cout << 0;
    }
    void show() const
    {
        cout << number;
    }
};
int main()
{
    Testing *pc1 , *pc2;
    pc1 = new Testing ;          //1
    pc2 = new Testing("Heap1");  //2
    pc1->show();   //3
    delete pc1 ;   //4
    delete pc2 ;   //5
    return 0;
}
```

the output at //1 is  `1`  (用默认的Testing) //2 is  `2` //3 is `7` //4 is `0` //5 is `0`

```c++
class A{
    int i;
public:
    A(int ii=0):i(ii) { cout << 1; }
    A(const A& a) {
        i = a.i;
        cout << 2;     
    }
    void print() const { cout << 3 << i; }
};
class B : public A {
    int i;
    A a;
public:
    B(int ii = 0) : i(ii) { cout << 4; }
    B(const B& b) {
        i = b.i;
        cout << 5;
    }
    void print() const {
        A::print();
        a.print();
        cout << 6 << i;    
    }
};
int main()
{
    B b(2);        //1
    b.print();    //2
    B c(b);        //3
    c.print();    //4
}
```

the output at //1 is  `114`  （B类里有个A类对象，所以构造B的时候A构造两次，输出11）

//2 is  `303062` //3 is `115` //4 is `303062` 



## 第八章 多态（Polymorphism）

Upcast: take an object of the derived class as an object of the base one

Dynamic binding:

- Binding: which function to be called
  - Static binding: call the function as the code（编译时进行。根据变量或表达式的静态类型来确定应该调用哪个函数）
  - Dynamic binding: call the function of the object（运行时进行。根据变量或表达式的动态类型来确定要调用的函数）

### 8.1 Virtual functions

- Non-virtual functions

  Compiler generates static, or direct call to stated type – Faster to execute

- Virtual functions

  - Can be transparently overridden in a derived class（在派生类里覆写）
  - Objects carry a pack of their virtual functions（产生一组虚函数）
  - Compiler checks pack and dynamically calls the right function（编译器在运行时动态调用）
  - If compiler knows the function at compile-time, it can generate a static call（编译时能确定就静态链接）

- Polymorphic variables
  - Pointers or reference variables of objects are polymorphic variables
  - They can hold objects of the declared type, or of subtypes of the declared type

### 8.2 虚函数表

- 虚函数表实现原理

  虚函数的实现是由两个部分组成的，虚函数指针与虚函数表。

  - 虚函数指针从本质上来说就只是一个指向函数的指针。它指向用户所定义的虚函数，具体是在子类里的实现，当**子类调用虚函数**的时候，实际上是通过调用该虚函数指针从而找到接口。

    在一个被实例化的对象中，它总是被存放在该对象的**地址首位**，这种做法的目的是为了保证运行的**快速性**。与对象的成员不同，虚函数指针对外部是完全不可见的，除非通过直接访问地址的做法或者在DEBUG模式中，否则它是**不可见的也不能被外界调用**。

    只有拥有虚函数的类才会拥有虚函数指针，每一个虚函数也都会对应一个虚函数指针。所以拥有虚函数的类的所有对象都会因为虚函数产生**额外的开销**，并且也会在一定程度上**降低程序速度**

  - 虚函数表（Virtual Table）

    ```c++
    class Base {
         public:
                virtual void f() { cout << "Base::f" << endl; }
                virtual void g() { cout << "Base::g" << endl; }
                virtual void h() { cout << "Base::h" << endl; }
    
    };
    ```

    对应的虚函数表：

    <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable1.jpg" alt="img" style="zoom: 80%;" />  

    - 一般继承（无虚函数覆盖）

      <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing3.jpg" alt="img" style="zoom:80%;" /> ===》<img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable2.JPG" alt="img" style="zoom:80%;" /> 

      虚函数按照其**声明顺序**放于表中

      **父类**的虚函数在子类的虚函数**前面**

    - 一般继承（有虚函数覆盖）

      <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing4.jpg" alt="img" style="zoom:80%;" /> ===》<img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable3.JPG" alt="img" style="zoom:80%;" /> 

      覆盖的f()函数**替换**了虚表中原来父类虚函数的位置。

      没有被覆盖的函数**依旧**。

      可以通过基类指针b调用子类的f()

      ```c++
       Base *b = new Derive();
       b->f();
      ```

    - 多重继承（无虚函数覆盖）

      <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing1.jpg" alt="img" style="zoom:80%;" /> ===》<img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable4.JPG" alt="img" style="zoom:80%;" /> 

      **每个**父类都有自己的虚函数表。

      子类的成员函数被放到了**第一个**父类的表中（第一个父类是按照**声明顺序**来判断的）

    - 多重继承（有虚函数覆盖）

      <img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_Drawing2.jpg" alt="img" style="zoom:80%;" /> ===》<img src="https://p-blog.csdn.net/images/p_blog_csdn_net/haoel/15190/o_vtable5.jpg" alt="img" style="zoom:80%;" /> 

      父类虚函数表中的被覆写函数的位置**都**被替换成了子类的函数指针。可以用**任一**静态类型的父类来指向子类，并调用子类的f()

      ```c++
       			Derive d;
                  Base1 *b1 = &d;
                  Base2 *b2 = &d;
                  Base3 *b3 = &d;
                  b1->f(); //Derive::f()
                  b2->f(); //Derive::f()
                  b3->f(); //Derive::f()
                  b1->g(); //Base1::g()
                  b2->g(); //Base2::g()
                  b3->g(); //Base3::g()
      ```

      

- ppt例子：

  ```c++
  class Shape {
  public:
      Shape();
      virtual ~Shape();
      virtual void render();
      void move(const int&);
      virtual void resize();
  protected:
      int center;
  };
  class Ellipse : public Shape {
  public:
      Ellipse(float majr, float minr);
      virtual void render();
  protected:
      float major_axis;
      float minor_axis;
  };
  class Circle : public Ellipse {
  public:
  Circle(float radius);
      virtual void render();
      virtual void resize();
      virtual float radius();
  protected:
      float area;
  };
  ```

  虚函数表变化：

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624194605938.png" alt="image-20230624194605938" style="zoom: 33%;" />  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624194616356.png" alt="image-20230624194616356" style="zoom: 33%;" /> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624194641129.png" alt="image-20230624194641129" style="zoom: 33%;" />  

  What happens if

  ```c++
  Ellipse elly(20F, 40F);
  Circle circ(60F);
  elly = circ; // 10 in 5?
  ```

  - Area of circ is sliced off(Only the part of circ that fits in elly gets copied)
  - Vtable from circ is **ignored**
  - the vtable in elly is the Ellipse vtable（```elly.render(); // Ellipse::render()```）

### 8.3 应用

- What happens with pointers?

  ```c++
  Ellipse* elly = new Ellipse(20F, 40F);
  Circle* circ = new Circle(60F);
  elly = circ;
  ```

  - the original Ellipse for elly is **lost**
  - elly and circ point to the **same Circle object**!`(elly->render(); // Circle::render()`)

- Virtuals and reference arguments

  ```c++
  void func(Ellipse& elly)
  {
  	elly.render();
  }
  Circle circ(60F);
  func(circ);
  ```

  - References act like pointers(类似传入指针)
  - `Circle::render() `is called

- Virtual destructors（基本一般函数一样）

  ```c++
  Shape *p = new Ellipse(100.0F, 200.0F); ...
  delete p;
  ```

  - Must declare Shape::~Shape() virtual，If Shape::~Shape() were not virtual, only Shape::~Shape() will be invoked!（如果基类析构不是虚函数，很显然就调用不了子类析构）
  - It will call Shape::~Shape() automatically（自动调用父类析构）

- Overriding

  Overriding redefines the body of a virtual function（重构）

  ```c++
  class Base {
  public:
  	virtual void func();
  }
  class Derived : public Base {
  public:
  	virtual void func(); //overrides Base::func()
  }
  ```

  - Superclass and subclass define methods with the same signature.
  - Each has access to the fields of its class.
  - Superclass satisfies static type check.
  - Subclass method is called at **runtime** – it overrides the superclass version.

- Return types relaxation

  看下面例子就明白了，只有指针引用可以

  ```c++
  class Expr {
  public:
      virtual Expr* newExpr();
      virtual Expr& clone();
      virtual Expr self();
  };
  class BinaryExpr : public Expr {
  public:
      virtual BinaryExpr* newExpr(); // Ok
      virtual BinaryExpr& clone(); // Ok
      virtual BinaryExpr self(); // Error!
  };
  ```

### 8.4 tips

- Never redefine an inherited non-virtual function
  - Non-virtuals are statically bound
  - No dynamic dispatch!

- Never redefine an inherited default parameter value
  - Theyʼre statically bound too!

### 8.5 Abstract class

- Some class is to create a common interface for all the classes derived from it.（有些类只作公共接口）
- An abstract method is incomplete. It has only a declaration and no method body.（纯虚函数：只有声明，like`virtual void render() = 0; `）
- A class containing abstract methods is called an abstract class.（包含纯虚函数的是虚类）
  - Abstract base classes cannot be instantiated(需类不能实例化，只能实例化派生类)
- 使用原因和时机：Modeling/interface
  - Force correct behavior
  - Define interface without defining an implementation
  - When designing for interface inheritance

- Mix and match
  - Members are duplicated
  - Derived class has access to full copies of each base class

```c++
class B1 { int m_i; };
class D1 : public B1 {};
class D2 : public B1 {};
class M : public D1, public D2 {};
void main() {
    M m; //OK
    B1* p = new M;     
    // 这里创建的是一个M对象，并将其赋值给一个B1类型的指针p。由于M同时继承自D1和D2，
    // 基类B1在M中有两个副本，因此编译器不知道应该选择哪一个基类的指针给变量p。
    // 编译器无法判断是要将p指向D1的部分还是D2的部分，因此会产生错误
    B1* p2 = dynamic_cast<D1*>(new M); // OK
    // 这里使用dynamic_cast进行类型转换，将M对象的指针转换为D1类型的指针p2。
    // 因为M类继承自D1和D2，所以指针p2可以正确地指向M对象中的D1部分。
    // 注意，使用dynamic_cast进行类型转换时，必须保证基类具有虚函数（或虚析构函数）。
    // 此处dynamic_cast成功，因为M继承自D1，它是合法的。
}
```

- Replicated bases

  Replication becomes a problem if replicated data makes for confusing logic:

  ```c++
  M m;
  m.m_i++; // ERROR: D1::B1.m_i or D2::B1.m_i?
  ```

### 8.6 Protocol classes

Abstract base class with

- All non-static member functions are pure virtual except destructor（全是纯虚函数或静态函数）
- Virtual destructor with empty body
- No non-static member variables, inherited or otherwise（只有静态的成员变量）

Using virtual base classes

- Virtual base classes are shared（虚基类被共享，而派生类只有一个虚基类的拷贝）
- Derived classes have a singlecopy of the virtual base
- Full control over sharing
  - Up to you to choose
- Cost is in complications

```c++
class B1 { int m_i; };
class D1 : virtual public B1 {};
class D2 : virtual public B1 {};
class M : public D1, public D2 {};
void main() {
    M m; //OK
    m.m_i++; // OK, there is only one B1 in m.
    B1* p = new M; // OK
}
```

Complications of MI

- 名称冲突：当派生类从多个基类继承时，可能会出现名称冲突的情况。如果两个或多个基类具有相同的成员名称，派生类必须明确指定要使用的成员。
- 优先规则（Dominance Rule）：在多重继承中，如果多个基类提供了相同的成员函数，派生类在调用该函数时会根据某种规则选择要调用哪个基类的版本。
- 构造顺序：在存在多个基类的情况下，决定构造函数和析构函数的执行顺序可能变得复杂。程序员需要注意控制派生类和各个基类的构造顺序，以避免潜在的错误和未定义行为。
- 谁构造虚基类？：当一个派生类继承了拥有虚基类的多个子类时，问题出现在哪个派生类负责构造虚基类的实例。这由编译器自动处理，但可能会导致不直观或令人困惑的行为。
- 虚基类在需要时未声明：如果在派生类的构造函数中尝试访问虚基类的成员，而虚基类尚未被构造，将无法访问到虚基类的成员。
- 虚基类中的代码调用多次：当派生类通过多个路径继承相同的虚基类时，虚基类中的代码可能会被调用多次，导致执行逻辑上的重复操作。
- 编译器支持度各不相同：不同的编译器对多重继承的处理方式可能有所差异，一些编译器可能实现不完全或存在行为上的偏差。

Virtual bases 评价

- Use of virtual base imposes some **runtime and space** overhead.
- If replication isnʼt a problem then you donʼt need to make bases virtual（能重复就不需要）
- Abstract base classes (that hold no data except for a vptr) can be replicated with no problem - virtual base can be eliminated.

### 8.7 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211326391.png" alt="image-20230624211326391" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211342351.png" alt="image-20230624211342351" style="zoom:67%;" /> 

没法构造基类了

 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211431961.png" alt="image-20230624211431961" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211455242.png" alt="image-20230624211455242" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211513046.png" alt="image-20230624211513046" style="zoom:67%;" /> 

共有的没法再重载了

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211555963.png" alt="image-20230624211555963" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211624820.png" alt="image-20230624211624820" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624211953000.png" alt="image-20230624211953000" style="zoom:67%;" /> 

 <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212023427.png" alt="image-20230624212023427" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212043327.png" alt="image-20230624212043327" style="zoom:67%;" /> 

选特性，其他不是特性？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212209568.png" alt="image-20230624212209568" style="zoom:67%;" /> 

还记得虚指针吗

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212426907.png" alt="image-20230624212426907" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212448487.png" alt="image-20230624212448487" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212501325.png" alt="image-20230624212501325" style="zoom:67%;" /> 

在C++中，可以声明指向抽象类的指针，因为指针本身并不需要知道具体派生类的信息，只要指针的类型能够匹配抽象基类即可

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624212637787.png" alt="image-20230624212637787" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624214548310.png" alt="image-20230624214548310" style="zoom:67%;" /> 

私有成员私有继承后无法直接访问，自然不是私有成员

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624214818663.png" alt="image-20230624214818663" style="zoom:67%;" /> 

构造的时候没法动态联编知道调用什么函数

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230624215058108.png" alt="image-20230624215058108" style="zoom:67%;" /> 



## 第九章 拷贝构造（Copy Constructor）

#### 9.1 Copying

Create a new object from an existing one

- The copy constructor

  - Copying is implemented by the copy constructor（复制是由复制构造函数实现）

  - Has the unique signature

    ```c++
    T::T(const T&);
    ```

  - Call-by-reference is used for the explicit argument（使用引用作为参数允许在函数内部修改传递的变量，并使这些修改对调用函数可见）

  - C++ builds a copy ctor for you if you don't provide one（有默认的拷贝构造）

    Copies each member variable

    - Good for numbers, objects, arrays– Copies each **pointer**

    - Data may become shared

  ex：

  ```c++
  Person::Person( const char *s ) {
      name = new char[::strlen(s) + 1];//The copy ctor initializes uninitialized memory（分配新内存）
      //Accesses s across client boundary（要有权限）
      ::strcpy(name, s); //No value returned
  }
  Person::~Person() {
      delete [] name;
  }
  ```

  

- 复制构造函数被调用的三种情况

  - 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。

    ```c++
    Complex c2(c1);
    Complex c2 = c1;//这两条语句是等价的。
    //注意，第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。
    Complex c1, c2; c1 = c2 ;
    c1=c2;//这条语句不会引发复制构造函数的调用，因为 c1 早已生成，已经初始化过了
    ```

  - 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。

    ```c++
    class A{
    public:
        A(){};
        A(A & a){
            cout<<"Copy constructor called"<<endl;
        }
    };
    void Func(A a){ }
    int main(){
        A a;
        Func(a);
        return 0;
    }//程序的输出结果为：Copy constructor called
    ```

    ```c++
    void roster( Person ); // declare function
    Person child( "Ruby" ); // create object
    roster( child ); // call function
    ```

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626010329900.png" alt="image-20230626010329900" style="zoom:50%;" /> 

  -  如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。

    ```c++
    Person captain() {
        Person player("George");
        return player;
    }
    ...
    Person who("");
    ...
    ```

    <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626010554231.png" alt="image-20230626010554231" style="zoom:50%;" /> 

    

- Copies and overhead

  - Compilers can "optimize out" copies when safe!（没必要就别用）

    Programmers need to

    - Program for "dumb" compilers
    - Be ready to look for optimizations

```c++
Person copy_func( char *who ) {
    Person local( who );
    local.print();
    return local; // copy ctor called!
}
Person nocopy_func( char *who ) {
    return Person( who );
} // no copy needed!
```

- Constructions vs. assignment
  - Every object is constructed once
  - Every object should be destroyed once（调不了delete或者delete多次不行）
  - Once an object is constructed, it can be the target of many assignment operations（对象被构造就可以对其进行多次赋值操作）

- What if the name was a string 
  - In the default copy ctor, the compiler recursively calls the copy ctors for all member objects (and base classes)
  - default is memberwise initialization（默认情况下是按成员初始化进行）

- Copy ctor guidelines
  - In general, be explicit：Create your own copy ctor -- don't rely on the default
  - If you don't need one declare a private copy ctor（不需要拷贝构造函数，则声明为私有）
    - prevents creation of a default copy constructor
    - generates a compiler error if try to pass-by-value - don't need a defintion

#### 9.2 types of function parameters and return value

传参类型

- a new object is to be created in f（要创建新对象）

  ```c++
  void f(Student i);
  ```

- better with const if no intend to modify the object（要是不想修改就串指针）

  ```c++
  void f(Student *p);
  ```

- better with const if no intend to modify the object（不想）修改就加const

  ```c++
  void f(Student& i);
  ```

返回类型

- Student f();： 返回一个 Student 类型的对象。在函数体内部，会创建一个新的 Student 对象，并将其作为返回值返回给调用者。调用者会得到一个复制后的新对象，它与原始对象互不影响的。


- Student* f();： 这个函数声明的返回类型是 Student*，表明它将会返回一个指向 Student 类型对象的指针。在函数体内部，会创建一个新的 Student 对象，并在堆上分配内存。然后将该对象的指针作为返回值返回给调用者。调用者会得到指向堆上创建的对象的指针，可以通过该指针来访问和操作对象。


- Student& f();： 这个函数声明的返回类型是 Student&，表明它将会返回一个指向 Student 类型对象的引用。在函数体内部，会创建一个新的 Student 对象，并将其引用作为返回值返回给调用者。调用者会得到对新创建对象的引用，可以直接使用该引用进行访问和修改。


#### 9.3 tips

很自然的选择：

- Pass in an object if you want to store it
- Pass in a const pointer or reference if you want to get the values
- Pass in a pointer or reference if you want to do something to it
- Pass out an object if you create it in the function
- Pass out pointer or reference of the passed in only
- Never new something and return the pointer（内存泄漏）

#### 9.4 Left Value vs Right Value

可以简单地认为能出现在赋值号左边的都是左值：

1. 变量本身、引⽤
2. `*` 、 `[]` 运算的结果

只能出现在赋值号右边的都是右值:

1. 字⾯量
1. 表达式

- 引⽤只能接受左值；—>引⽤是左值的别名

- 调⽤函数时的传参相当于参数变量在调⽤时的初始化

- 右值引⽤

  ```c++
  int x=20; // 左值
  int&& rx = x * 2; // x*2的结果是⼀个右值，rx延⻓其⽣命周期
  int y = rx + 2; // 因此你可以重⽤它:42
  rx = 100; // ⼀旦你初始化⼀个右值引⽤变量，该变量就成为了⼀个左值，可以被赋值
  int&& rrx1 = x; // ⾮法:右值引⽤⽆法被左值初始化
  const int&& rrx2 = x; // ⾮法:右值引⽤⽆法被左值初始化
  ```

- 右值参数

  ```c++
  // 接收左值
  void fun(int& lref) {
      cout << "l-value" << endl;
  }
  // 接收右值
  void fun(int&& rref) {
      cout << "r-value" << endl;
  }
  int main() {
  int x = 10;
      fun(x); // output: l-value reference
      fun(10); // output: r-value reference
  }
  ```

- const引⽤参数（也能接受右值）

  ```c++
  void fun(const int& clref) {
      cout << "l-value const reference\n";
  }
  ```

#### 9.5 移动拷⻉函数

参数为右值引⽤的拷⻉构造函数

```c++
vector<int> v1{1, 2, 3, 4};
vector<int> v2 = v1; // 此时调⽤⽤复制构造函数，v2是v1的副本vector<int> v3 = std::move(v1); // 此时调⽤⽤移动构造函数
```

#### 9.6 对象初始化的形式

```c++
//⼩括号初始化
string str("hello");
//等号初始化
string str = "hello";
//⼤括号初始化
struct Studnet
{
char *name;
int age;
};
Studnet s = {"dablelv"
, 18};//Plain of Data类型对象
Studnet sArr[] = {{"dablelv"
, 18}, {"tommy"
, 19}}; //POD数组
```

- 列表初始化

  ```c++
  class Test
  {
      int a;
      int b;
  public:
      Test(int i, int j);
  };
  Test t{0, 0}; //C++11 only，相当于 Test t(0,0);
  Test *pT = new Test{1, 2}; //C++11 only，相当于 Test* pT=new Test(1,2);
  int *a = new int[3]{1, 2, 0}; //C++11 only
  ```

- 容器初始化

  ```c++
  // C++11 container initializer
  vector<string> vs={ "first", "second", "third"};
  map<string,string> singers ={ {"Lady Gaga", "+1 (212) 555-7890"},{"Beyonce Knowles", "+1 (212) 555-0987"}};
  ```

- `std::swap()`

  ```c++
  void swap(T& a, T& b) {
      T tmp{a}; // 调⽤⽤拷⻉构造函数
      a = b; // 拷⻉赋值运算符
      b = tmp; // 拷⻉赋值运算符
  }
  void swap(T& a, T& b) {
      T temp{std::move(a)};
      a = std::move(b);
      b = std::move(tmp);
  }
  ```

- Delegating Ctor

  ```c++
  class class_c {
  public:
  int max;
  int min;
  int middle;
  class_c(int my_max) {
      max = my_max > 0 ? my_max : 10;
  }
  class_c(int my_max, int my_min) : class_c(my_max) {
      min = my_min > 0 && my_min < max ? my_min : 1;
  }
  class_c(int my_max, int my_min, int my_middle) : class_c (my_max, my_min){
      middle = my_middle < max && my_middle > min ? my_middle : 5;
  }
  };
  int main() {
      class_c c1{ 1, 3, 2 };
  }
  ```

#### 9.7 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023006479.png" alt="image-20230626023006479" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023036938.png" alt="image-20230626023036938" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023133530.png" alt="image-20230626023133530" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023154678.png" alt="image-20230626023154678" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023228598.png" alt="image-20230626023228598" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023427329.png" alt="image-20230626023427329" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023510271.png" alt="image-20230626023510271" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230626023723558.png" alt="image-20230626023723558" style="zoom:50%;" /> 

程序填空比较简单(\*\^▽^*)



## 第十章 运算符重载（Overloaded operators ）

Allows user-defined types to act like built in types

Another way to make a **function call**

#### 10.1 Overloaded operators

- operators **can be** overloaded（Unary and binary ）:

  \+ - * / % ^ & | ~  = < > += -= *= /= %= ^= &= |= << >> >>= <<= == 

   != <= >= ! && || ++ --  **,** ->* -> () []

  operator new operator delete

  operator new[] operator delete[]

- **can't overload**：

  .   .*   ::   ?:
  sizeof typeid
  static_cast dynamic_cast const_cast
  reinterpret_cast

- Restrictions：

  - Only existing operators can be overloaded (只能重载现有运算符，不能自创)
  - Operators must be overloaded on a class or enumeration type（必须在类或枚举类型上重载）
  - Preserve number of operands & Preserve precedence（操作数和优先级会保留）

#### 10.2 C++ overloaded operator

- Just a function with an operator name（只是个函数）

  —Use the operator keyword as a prefix to name `operator *(…)`

- Can be a member function （可以是成员函数）
  –Implicit first argument（。。。）

  ```c++
  const String String::operator +(const String& that);
  ```

- Can be a global (free) function（可以是正常的函数）

  –Both arguments explicit

  ```c++
  const String **operator+**(const String& r, const String& l);
  ```

#### 10.3 How to overload

- As member function

  –Implicit first argument

  –No type conversion performed on receiver

  –Must have access to class definition

  ```c++
  class Integer {
  public:
       Integer( int n = 0 ) : i(n) {}
       const Integer operator+(const Integer& n) const{
       return Integer(i + n.i);
   }
   ... 
  private:
       int i;
  };
  ```

- For binary operators (+, -, *, etc) member functions require one argument.（二元需要一个参数）

- For unary operators (unary -, !, etc) member functions require no arguments（一元需要一个）

  ```c++
   const Integer operator-() const {
       return Integer(-i);
   }
   ...
   z = -x; // z.operator=(x.operator-());
  ```

- • As a **global** function

  –Explicit first argument

  –Type conversions performed on both arguments

  ```c++
  const Integer operator+( 
   const Integer& rhs, 
   const Integer& lhs);
  Integer x, y;
  x + y ====> operator+(x, y);
  ```

  –Can be made a **friend**

  ```c++
  class Integer {
   friend const Integer operator+ (
   const Integer& lhs,
   const Integer& rhs);
   ...
  }
  const Integer operator+( 
   const Integer& lhs, 
   const Integer& rhs){
       return Integer( lhs.i + rhs.i );
  }
  ```

  - binary operators require two arguments
  - unary operators require one argument

- Tips: Members vs. Free Functions

  - **Unary** operators **should be** members（通常在单个对象上操作，并且不需要额外的参数）
  -  **= () [] -> ->*** **must be** members
  - assignment operators should be members（涉及访问或操作对象内部的成员）
  - All **other** **binary** operators as **non**-members 

- The prototypes of operators

  -  - */%^&|~

    –`const T operatorX(const T& l, const T& r);`

  - ! && || < <= == >= >

    –`bool operatorX(const T& l, const T& r);`

    ```c++
    bool Integer::operator==( const Integer& rhs ) const {
         return i == rhs.i;
    }
    // implement lhs != rhs in terms of !(lhs == rhs)
    bool Integer::operator!=( const Integer& rhs ) const {
         return !(*this == rhs); 
    }
    bool Integer::operator<( const Integer& rhs ) const {
         return i < rhs.i;
    }
    ```

  - [] 

    –`E& T::operator[](int index);`

  - operators ++ and --

    ```c++
    const Integer& Integer::operator++() {
         *this += 1; // increment
         return *this; // fetch
    } 
    // int argument not used so leave unnamed so
    // won't get compiler warnings
    const Integer Integer::operator++( int ){
         Integer old( *this ); // fetch
         ++(*this); // increment
         return old; // return 
    }
    ```

- Defining a stream extractor / stream inserter

  - Has to be a 2-argument free function

    –First argument is an istream&

    –Second argument is a *reference* to a value

    ```c++
    istream& operator>>(istream& is, T& obj) {
     // specific code to read obj
        return is;
    }
    ```

    ```c++
    ostream& operator<<(ostream& os, const T& obj) {
     // specific code to write obj
        return os;
    }
    ```

#### 10.4 Copying vs. Initialization 

- Automatic operator= creation

  The compiler will automatically create a `type::operator=(type)` if you don’t make one.

- Assignment Operator

  - Must be a member function
  - Be sure to assign to all data members
  - Return a reference to ***this**

  ```c++
  T& T::operator=( const T& rhs ) {
   // check for self assignment
   if ( this != &rhs) {
   // perform assignment
   }
   return *this;
  }
  ```

  - For classes with dynamically allocated memory declare an assignment operator (and 

    a copy constructor)

  - To prevent assignment, explicitly declare operator= as **private**

#### 10.5 User-defined Type conversions

- A conversion operator can be used to convert an object of one class into 

  –an object of another class

  –a built-in type

- Compilers perform implicit conversions using:

  –Single-argument constructors

  –implicit type conversion operators

- Preventing implicit conversions（只用定义过的显示转换）

  `explicit`关键字

  ```c++
  class PathName {
   string name;
  public:
   explicit PathName(const string&);
   ~ PathName();
  };
  ...
  string abc("abc");
  PathName xyz(abc); // OK!
  xyz = abc; // error!
  ```

- C++ type conversions

  - Built-in conversions

    Primitive：char ⇒ short ⇒ int ⇒ float ⇒ double ⇒ int ⇒ long

    –Implicit (for any type T)：

    ```c++
    T⇔T&
    T&→T
    T*=void*
    T→ const T
    T[]=T*
    T*=T[]
    ```

- Overloading and type conversion

  - C++ checks each argument for a "best match"

  - Best match means cheapest

    –Exact match is cost-free

    –Matches involving built-in conversions

    –User-defined type conversions

- Overloading tips

  - Just because you can overload an operator doesn't mean you should.（可以但不一定好）
  - Overload operators when it makes the code easier to read and maintain.（可读性和可维持性）
  - Don't overload && || or , (the comma operator)

#### 10.6 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627134655679.png" alt="image-20230627134655679" style="zoom: 50%;" /> <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627134729212.png" alt="image-20230627134729212" style="zoom:50%;" /> 

 C++规定有四个运算符 **=, ->, [], ()**不可以是全局域中的重载（即不能重载为友元函数），这几个太常用了？？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135239356.png" alt="image-20230627135239356" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135331353.png" alt="image-20230627135331353" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135346411.png" alt="image-20230627135346411" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135404056.png" alt="image-20230627135404056" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135458355.png" alt="image-20230627135458355" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135514477.png" alt="image-20230627135514477" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135554557.png" alt="image-20230627135554557" style="zoom:50%;" /> 

没有friend？？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135724451.png" alt="image-20230627135724451" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135738278.png" alt="image-20230627135738278" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135758745.png" alt="image-20230627135758745" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135931704.png" alt="image-20230627135931704" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627135945165.png" alt="image-20230627135945165" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140153005.png" alt="image-20230627140153005" style="zoom:50%;" /> .

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140209088.png" alt="image-20230627140209088" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140300847.png" alt="image-20230627140300847" style="zoom:50%;" /> 

这个int就是为了区分

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140802614.png" alt="image-20230627140802614" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140842442.png" alt="image-20230627140842442" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140902398.png" alt="image-20230627140902398" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627140941101.png" alt="image-20230627140941101" style="zoom:50%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627141026699.png" alt="image-20230627141026699" style="zoom:50%;" /> 

## 第十一章 模板（Templates）

- Why templates：不同类型的相同对象

  Reuse source code （重用）

  –generic programming （泛型编程）

  –use types as parameters in class or function definitions （类型做参数）

#### 11.1 函数模板（Function Templates）

- Perform similar operations on different types of data.（都是这样）

  EX：swap function template

  ```c++
  template < class T > 
  void swap( T& x, T& y ) { 
       T temp = x; 
       x = y; 
       y = temp; 
  }
  ```

- The `template` keyword introduces the template 

- The `class T` specifies a parameterized type name 

   class means any built-in type or user-defined type （class表示任何内置类型或自定义的类型）

- Inside the template, use T as a type name （模板中用T做类型名称）

- Function Template Syntax（语法）

  - Parameter types represent: （T可以做参数、返回类型、新定义的变量）

    –types of arguments to the function 

    –return type of the function 

    –declare variables within the function

#### 11.2 模板实例化（Template Instantiation）

Generating a declaration from a template class/function and template arguments: 

–Types are substituted into template （传入的类型替换模板）
–New body of function or class definition is created （建立一个新函数体，编译器会根据提供的参数将模板中的类型进行替换，并生成相应的函数或类定义）
–Specialization -- a version of a template for a particular argument（基本变成正常函数了？？）

```c++
// 模板通用实现
template<typename T>
void print(T value) {
    std::cout << "Generic Print: " << value << std::endl;
}
// 字符串特化实现
template<>
void print<const char*>(const char* value) {
    std::cout << "Specialized Print for const char*: " << value << std::endl;
}
```

- Interactions

  - Only *exact* match on types is used 

  - No conversion operations are applied 

    ```c++
    swap(int, int); // ok 
    swap(double, double); // ok 
    swap(int, double); // error!
    ```

  - Even *implicit* conversions are ignored （就是不能传double给int这样的）

- Overloading rules（优先普通函数，其次在寻找模板函数）

  - Check first for unique function match 

  - Then check for unique function template match

  - Then do overloading on functions 

    ```c++
    void f(float i,float k) {}; 
    template <class T> 
    void f(T t, T u) {}; 
    f(1.0,2.0); //调void f(T t, T u) {}; (1.0不是float。。。)
    f(1,2); //调f(T t, T u) {}; 
    f(1,2.0);//f(float i,float k) {}; 
    ```

- The compiler deduces the template type from the actual arguments passed into the function（编译器从传递到函数中的实际参数中推导出模板类型）

- Can be explicit: 

  –for example, if the parameter is not in the function signature (older compilers won't allow this...我的就不允许？？) 

  ```c++
   template < class T > 
   void foo( void ) { /* ... */ } 
   foo<int>(); // type T is int 
   foo<float>(); // type T is float
  ```

#### 11.3 类模板（Class templates）

Classes parameterized by types

–Abstract operations from the types being operated upon （来自正在操作的类型的抽象操作）

–Define potentially infinite set of classes 

–Another step towards reuse! 

EX：

```c++
template <class T> 
class Vector { 
public: 
     Vector(int); 
     ~Vector(); 
     Vector(const Vector&); 
     Vector& operator=(const Vector&); 
     T& operator[](int); 
private: 
     T* m_elements; 
     int m_size; 
};
Vector<int> v1(100); 
Vector<Complex> v2(256); 
v1[20] = 10; 
v2[20] = v1[20]; // ok if int->Complex 
 // defined
```

- Templates can use **multiple** types 

  ```c++
  template< class Key, class Value> 
  class HashTable { 
       const Value& lookup(const Key&) const; 
       void install(const Key&, const Value&); 
   ... 
  };
  ```

  

#### 11.4 Templates and inheritance

- Templates can inherit from non-template classes （模板可以从非模板类中继承）

  ```c++
  template <class A> 
  class Derived : public Base { ...}
  ```

- Templates can inherit from template classes （模板可以从模板类中继承）

  ```c++
  template <class A> 
  class Derived : public List<A> { ...}
  ```

- Non-template classes can inherit from templates （非模板类可以从模板中继承）

  ```c++
  class SupervisorGroup : public 
  List<Employee*> { ...}
  ```

  

#### 11.5 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154105630.png" alt="image-20230627154105630" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154125578.png" alt="image-20230627154125578" style="zoom:67%;" /> 

特化模板，需要具体类型

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154637945.png" alt="image-20230627154637945" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154656428.png" alt="image-20230627154656428" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154717353.png" alt="image-20230627154717353" style="zoom:67%;" /> 

两个得一致

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627154915821.png" alt="image-20230627154915821" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155002157.png" alt="image-20230627155002157" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155022006.png" alt="image-20230627155022006" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155144544.png" alt="image-20230627155144544" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155202351.png" alt="image-20230627155202351" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155217648.png" alt="image-20230627155217648" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155232643.png" alt="image-20230627155232643" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155509896.png" alt="image-20230627155509896" style="zoom:67%;" /> 

编译时就确定好类型了

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155646310.png" alt="image-20230627155646310" style="zoom:67%;" /> 

？？？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155815434.png" alt="image-20230627155815434" style="zoom:67%;" /> 

模板来定义，函数来使用

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627155901114.png" alt="image-20230627155901114" style="zoom:67%;" /> 

`pair<>` 是 C++ 标准库中提供的一个类模板，用于表示包含两个值的有序对。它位于 `<utility>` 头文件中。

可以使用以下语法来创建和初始化 `pair<>` 对象：

```c++
std::pair<T1, T2> p;                 // 默认构造函数创建一个空的 pair 对象
std::pair<T1, T2> p(val1, val2);     // 使用给定的 val1 和 val2 值初始化 pair 对象
```

其中，`T1` 和 `T2` 是实际类型参数，可以是任何合法的 C++ 类型。

以下是一些使用 `pair<>` 的示例：

```c++
#include <iostream>
#include <utility>
int main() {
    // 创建并初始化 pair 对象
    std::pair<int, std::string> p1(42, "hello");
    // 获取 pair 对象的成员元素
    int first = p1.first;
    std::string second = p1.second;
    // 修改 pair 对象的成员元素
    p1.first = 24;
    p1.second = "world";
    // 输出 pair 对象的值
    std::cout << "First: " << p1.first << std::endl;
    std::cout << "Second: " << p1.second << std::endl;
    return 0;
}
```

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627160224106.png" alt="image-20230627160224106" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627160236126.png" alt="image-20230627160236126" style="zoom:67%;" /> 



## 第十二章 异常（Exceptions）

At the point where the problem occurs, you might not know what to do with it, but you do know that you can’t just continue on merrily; you must stop, and somebody, somewhere, must fifigure out what to do.

- Why exception?

  - they clean up error handling code.（代码好看）
  - It separates the code that describes what you want to do from the code that is executed（描述代码和执行代码分开）

- How to raise an exception

  ```c++
  template <class T> 
  T& Vector<T>::operator[](int indx) { 
  if (indx < 0 || indx >= m_size) { 
   // throw is a keyword 
   // exception is raised at this point 
      throw <<something>>; 
  } 
  	return m_elements[indx]; 
  }
  ```

- What about your caller

  **Case 1)** Doesn’t care 

  –Code never even suspects a problem 

  ```c++
  int func() { 
      Vector<int> v(12); 
      v[3] = 5; 
      int i = v[42]; // out of range 
      // control never gets here! 
      return i * 5; 
  }
  ```

  **Case 2)** Cares deeply （分辨具体类型进行处理）

  ```c++
  void outer() { 
       try {
           func(); func2(); 
       } catch (VectorIndexError& e) {
      	 e.diagnostic(); 
       	// This exception does not propagate 
       } 
       cout << "Control is here after 
      exception"; 
  }
  ```

  **Case 3)** Mildly interested （单一处理）

  ```c++
  void outer2() { 
       String err("exception caught"); 
       try {
           func(); 
       } catch (VectorIndexError) { 
           cout << err; 
           throw; // propagate the exception 
       } 
  }
  ```

  **Case 4)** Doesn’t care about the particulars（全部）

  ```c++
  void outer3() { 
       try {
           outer2(); 
       } catch (...) { 
           // ... catches ALL exceptions! 
           cout << "The exception stops here!"; 
       } 
  }
  ```

- Throw statement **raises** the exception 

  –Control propagates back to first handler for that exception （回到该异常的第一个处理程序）

  –Propagation follows the **call** **chain** 

  –Objects on **stack** are properly destroyed 

- Try blocks

```c++
try { ... } 
 catch ... 
 catch ...
```

Establishes any number of handlers

- Exception handlers

  ```c++
  catch (SomeType v) { // handler code 
   } 
  catch (...) { // handler code 
   }
  ```

  - Select exception by type （根据类型选择）
  - Can re-raise exceptions （可重复）
  - Take a single argument（单个参数）

- Selecting a handler

  Handlers are checked in order of appearance：

  1. Check for **exact match** 
  2. Apply **base class** conversions  Reference and pointer types, only 

  3. Ellipses (**...**) match all 

  Inheritance can be used to structure exceptions（继承异常）

  ```c++
  class MathErr { 
  ... 
  virtual void diagnostic(); 
  }; 
  class OverflowErr : public MathErr { ... } 
  class UnderflowErr : public MathErr { ... } 
  class ZeroDivideErr : public MathErr { ... }
  
  try { 
   // code to exercise math options 
   throw UnderFlowErr(); 
  } catch (ZeroDivideErr& e) { 
   // handle zero divide case 
  } catch (MathErr& e) { 
   // handle other math errors 
  } catch (...) { 
   // any other exceptions 
  }
  ```

- Exceptions and new

  new raises a bad_alloc() exception （`new`可能引发内存分配异常）

#### 12.1 Standard library exceptions

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627183729073.png" alt="image-20230627183729073" style="zoom:67%;" /> 

- Exception specifications

  Declare which exceptions function might raise（对函数可能引发的异常进行声明的一种方式，它是函数原型的一部分）

  - Not checked at compile time （At **run time**）
  - if an exception not in the list propagates out, the `unexpected` exception is raised（如果一个未在异常规格列表中的异常传播到函数外部，那么就会引发未知异常)

  ```c++
  Printer::print(Document&) : throw(PrinterOffLine, BadDocument) 
  PrintManager::print(Document&) : throw (BadDocument) { ... 
   // raises or doesn’t handle BadDocument 
  void goodguy() : throw () { 
   // handles all exceptions 
  void average() { } // no spec, no checking,
  ```

#### 12.2 Summary

- Exceptions provide the mechanism 

  –Propagated dynamically (运行时动态地传播异常)

  –Objects on stack destroyed properly （确保栈上的对象被正确销毁）

  –Act to terminate the problematic function （终止出现问题的函数的执行）

- Another big use: 

  –Constructors that can’t complete their work

#### 12.3 More exceptions

- Failure in constructors： Better to Throw an exception

  -  Dtors for objects whose ctor didn’t complete won’t be called. （对象的析构函数将不会被调用。这是因为对象尚未完全构造成功，所以析构函数的执行没有意义）.
  - Clean up allocated resources before throwing（适当的清理）

- Two stages construction

  1. Do normal work in ctor （始化所有成员对象、初始化所有基本类型成员和将指针初始化为 0）

     –Initialize all member objects 

     –Initialize all primitive members 

     –Initialize all pointers to 0 

     –NEVER request any resource （不应该请求任何资源，如文件、网络连接或内存等。通过避免在构造函数中进行可能引发异常或错误的操作）

  2. Do addition initialization work in Init()（资源请求更加安全）

- Exceptions and destructors
  - Throwing an exception in a destructor that is itself being called as the result of an exception will invoke `std::terminate()`.（在析构函数中抛出异常并且该析构函数本身是作为另一个异常的结果被调用时，会触发 `std::terminate()` 函数，导致程序的终止。）
  - Allowing exceptions to escape from destructors should be avoided.（在析构函数中抛出异常的同时，堆栈上可能还有其他未处理的异常，而这样的情况无法恢复或继续执行。因此，应该尽量**避免从析构函数中抛出异常**）

#### 12.4 Programming with exceptions

- Prefer catching exceptions by **reference** ：Throwing/catching by value involves slicing

  异常对象是按值进行传递的，当我们以基类类型 `X` 进行捕获时，实际上会发生对象切片。这意味着只会复制 `Y` 对象的 **`X` 部分**，而被称为切片

  ```c++
  struct X {}; 
  struct Y : public X {}; 
  try { 
  throw Y(); 
  } catch(X x) { 
   // was it X or Y? 
  }
  ```

- Throwing/catching by pointer introduces coupling between normal and handler code（正常代码和异常处理代码之间引入耦合关系）

  ```c++
  try { 
  throw new Y(); 
  } catch(Y* p) { 
   // whoops, forgot to delete.. 
  }
  ```

- Catch exceptions by reference

  ```c++
  struct B { 
   virtual void print() { /* … */ } 
  }; 
  struct D : public B { /* … */ }; 
  try { 
  	throw D(“D error”); 
  } 
  catch(B& b) { 
   b.print() // print D’s error. 
  }
  ```

- Exception Hierarchies

  ```c++
  try { 
   … throw SomethingElse(); 
  } 
  catch(This& t) { /* … */ } 
  catch(That& t) { /* … */ } 
  catch(Other& t) { /* … */ }
  
  class B {}; 
  class D1 : public B {}; 
  class D2 : public B {}; 
  ... 
  try { 
   … throw D1(); 
  } 
  catch(D2& t) { /* catch specific class here */ } 
  catch(B& t) { /* anything else here. */ }
  ```

- Unexpected exceptions（定义了函数可能抛出的异常类型）

  ```c++
  void f() throw(X, Y) {/* may throw X and Y */} 
  void g() throw() {/* throws no exceptions */} 
  void h() {/* may throw any exception*/}
  ```

  如果函数 `f()` 抛出了与其异常规范不一致的异常类型，即抛出了除 `X` 和 `Y` 之外的其他类型的异常，则会触发异常规范的违反（exception specification violation）。这将导致程序的终止并调用 `std::unexpected()` 函数，该函数默认会调用 `std::terminate()` 来终止程序。

  对于函数 `g()`，在其异常规范为 `throw()`、即**不允许抛出任何异常**的情况下，如果函数 `g()` 确实抛出了异常，也会触发异常规范的违反。同样，这将导致程序的终止。

  - Offers a guarantee (and firewall) to callers.
  - unexpected() behavior can be intercepted

- Uncaught exceptions

  - If an exception is thrown by not caught `std::terminate()` will be called（当异常在程序的调用链上未被处理（即没有匹配的异常处理代码）时，就会引发未处理的异常）
  - terminate() can also be intercepted. 

- Exceptions wrapup
  - Develop an error-handling strategy early in design. 
  - Avoid over-use of try/catch blocks. Use **objects** to acquire/release resources. 
  - Don’t use exceptions where local control structures will suffice （别添足）
  - Not every function can handle every error.
  - Use exception-specifications for major interfaces. （主要接口用异常规范）
  - Library code should not decide to terminate a program. Throw exceptions and let caller decide

#### 12.5 题目

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191417126.png" alt="image-20230627191417126" style="zoom:67%;" /> 

`catch (...)`

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191532490.png" alt="image-20230627191532490" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191555379.png" alt="image-20230627191555379" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191610959.png" alt="image-20230627191610959" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191657275.png" alt="image-20230627191657275" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627191710187.png" alt="image-20230627191710187" style="zoom:67%;" /> 

Segmentation fault！！

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627192052252.png" alt="image-20230627192052252" style="zoom:80%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627192331935.png" alt="image-20230627192331935" style="zoom:67%;" /> 

`exception` 类提供了一个名为 `what()` 的虚成员函数，用于返回与异常相关的描述或消息的字符串。

派生类，如 `runtime_error`、`overflow_error` 和 `bad_exception`，都继承自 `exception` 类。它们可以重写 `what()` 函数，以提供自己特定的实现来返回有关错误的信息。

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627192433361.png" alt="image-20230627192433361" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627192607555.png" alt="image-20230627192607555" style="zoom:67%;" /> 

Exception2 is derived from Exception1（没看题想半天）

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193300344.png" alt="image-20230627193300344" style="zoom:67%;" /> 

问题：statement2执行完后，下一条被执行的语句是什么？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193438644.png" alt="image-20230627193438644" style="zoom:67%;" /> 

在函数声明的形参表后没有任何表示异常类型的说明，那就表示该函数可以抛出任意类型的异常；`throw()`表示该函数不会抛出任何异常

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193627381.png" alt="image-20230627193627381" style="zoom:67%;" /> 

重抛异常是指在异常处理块（catch）内部将当前捕获的异常重新抛出

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193819371.png" alt="image-20230627193819371" style="zoom:67%;" /> 

异常是运行时错误？？

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193857723.png" alt="image-20230627193857723" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627193933297.png" alt="image-20230627193933297" style="zoom:67%;" /> 

应该在更高的异常处理层级中寻找匹配的`catch`语句进行处理

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194038348.png" alt="image-20230627194038348" style="zoom:67%;" /> 

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230627194138004.png" alt="image-20230627194138004" style="zoom:67%;" /> 

程序填空：

```c++
#include <iostream>
using namespace std;
enum ERROR{UnderFlow,OverFlow};
template<typename T>
class StackTemplate {
    enum { ssize = 100 };
    T stack[ssize];
    int top;
public:
    StackTemplate() : top(0) {}
    void push(const T& i) {
        if (top >= ssize)  
			【throw OverFlow】;
        	stack[top++] = i;
    }
    T pop() {
        if (top【<=0】) throw UnderFlow;
        return stack[--top];
    }
    int size() const
    { return top; }
};
int fibonacci(int n);

int main() {
    
	【try】{
        【StackTemplate<int>】 is;
        for(int i = 0; i < 20; i++)
            is.push(fibonacci(i));
        for(int k = 0; k < 20; k++)
            cout << is.pop() << "\t";
    }
    catch( ERROR e ) {
        switch(【e】)
        {
        case OverFlow:
            exit;
        case UnderFlow:
            exit;
        }
    }
    catch(...)
    {
        exit;
    }
    return 0;
}

int fibonacci(int n) 
{
【const】int sz = 100;
    int i;
    static int f[sz]; 
    if (n >= sz) 【exit】;
       f[0] = f[1] = 1;
    for(i = 0; i < sz; i++)
        if(f[i] == 0) break;
    while(i <= n) {
        【f[i]】= f[i-1] + f[i-2];
        i++;
    }
    return 【f[n]】;
}
```

